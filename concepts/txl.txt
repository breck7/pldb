TXL
===

TXL is a programming language created in 1985 by James Cordy.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%221985%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D
 https://pldb.io/concepts/../lists/creators.html#q=James%20Cordy

#1329 on PLDB
39 Years Old
69 Repos

TXL is a special-purpose programming language originally designed by Charles Halpern-Hamu and James Cordy at the University of Toronto in 1985.  The acronym "TXL" originally stood for "Turing eXtender Language" after the language's original purpose, the specification and rapid prototyping of variants and extensions of the Turing programming language, but no longer has any meaningful interpretation. Modern TXL is specifically designed for creating, manipulating and rapidly prototyping language-based descriptions, tools and applications using source transformation. Read more on Wikipedia...
 https://en.wikipedia.org/wiki/TXL_(programming_language)

- TXL Wikipedia page
 https://en.wikipedia.org/wiki/TXL_(programming_language)
- There are at least 69 TXL repos on GitHub
- The  Google BigQuery Public Dataset GitHub snapshot shows 22 users using TXL in 22 repos on GitHub
- TXL on HOPL
 https://hopl.info/showlanguage.prx?exp=1444
- GitHub supports syntax highlighting for TXL
- See also: (3 related languages)Turing, Yacc, Refal

% Calculator.Txl - simple numerical expression evaluator

% Part I.  Syntax specification
define program
        [expression]
end define

define expression
        [term]
    |   [expression] [addop] [term]
end define

define term
        [primary]
    |   [term] [mulop] [primary]
end define

define primary
        [number]
    |   ( [expression] )
end define

define addop
        &#39;+
    |   &#39;-
end define

define mulop
        &#39;*
    |   &#39;/
end define

% Part 2.  Transformation rules
rule main
    replace [expression]
        E [expression]
    construct NewE [expression]
        E [resolveAddition] [resolveSubtraction] [resolveMultiplication]
          [resolveDivision] [resolveParentheses]
    where not
        NewE [= E]
    by
        NewE
end rule

rule resolveAddition
    replace [expression]
        N1 [number] + N2 [number]
    by
        N1 [+ N2]
end rule

rule resolveSubtraction
    replace [expression]
        N1 [number] - N2 [number]
    by
        N1 [- N2]
end rule

rule resolveMultiplication
    replace [term]
        N1 [number] * N2 [number]
    by
        N1 [* N2]
end rule

rule resolveDivision
    replace [term]
        N1 [number] / N2 [number]
    by
        N1 [/ N2]
end rule

rule resolveParentheses
    replace [primary]
        ( N [number] )
    by
        N
end rule

function fact
   replace [number]
      n [number]
   construct nMinusOne [number]
      n [- 1]
   where
      n [&gt; 1]
   construct factMinusOne [number]
      nMinusOne [fact]
   by
      n [* factMinusOne]
end function
      
function fact0
 replace [number]
      0
 by
      1
end function
