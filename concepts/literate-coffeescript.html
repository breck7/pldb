<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <title>Literate CoffeeScript - Programming language</title>
 <script>/* This HTML was generated by üìú Scroll v136.4.1. https://scroll.pub */</script>
 <style>@media print {.doNotPrint {display: none !important;}}</style>
 <link rel="canonical" href="https://pldb.io/concepts/literate-coffeescript.html">
 <meta name="viewport" content="width=device-width,initial-scale=1">
 <meta name="description" content="Besides being used as an ordinary programming language, CoffeeScript may also be written in ‚Äúliterate‚Äù mode. If you name your file with a .litcoffee extension, you can write it as a Markdown document ‚Äî a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown‚Äôs way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.">
 <meta name="generator" content="Scroll v136.4.1">
 <meta property="og:title" content="Literate CoffeeScript - Programming language">
 <meta property="og:description" content="Besides being used as an ordinary programming language, CoffeeScript may also be written in ‚Äúliterate‚Äù mode. If you name your file with a .litcoffee extension, you can write it as a Markdown document ‚Äî a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown‚Äôs way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.">
 <meta property="og:image" content="">
 
 <link rel="source" type="application/git" title="Source Code Repository" href="https://github.com/breck7/pldb">
 <link rel="alternate" type="application/rss+xml" title="Literate CoffeeScript - Programming language" href="../blog/feed.xml">
 <meta name="twitter:card" content="summary_large_image">
</head>
<body>
<link rel="stylesheet" type="text/css" href="../gazette.css"></link>
<link rel="stylesheet" type="text/css" href="../TrueBaseTheme.css"></link>

<div class="trueBaseThemeHeader">
 <a href="../index.html" class="trueBaseThemeLogo">PLDB</a>
 <form style="display:inline-block;" method="get" action="../lists/explorer.html">
  <input type="search" id="trueBaseThemeHeaderSearch" name="q" placeholder="Search" autocomplete="off"></input>
</form>
 <a href="../lists/top1000.html">Top 1K</a>
 <a href="../lists/features.html">Features</a>
 <a href="../lists/creators.html">Creators</a>
 <a href="../lists/events.html">Events</a>
 <a href="../lists/podcasts.html">Podcasts</a>
 <a href="../books/index.html">Books</a>
 <a href="../lists/extensions.html">Extensions</a>
 <a href="../blog/interviews.html">Interviews</a>
 <a href="../blog/index.html">Blog</a>
 <a href="../lists/explorer.html">Explorer</a>
 <a href="../csv.html">CSV</a>
</div>

<style>.abstractIconButtonParser {position:absolute;top:0.25rem; }.abstractIconButtonParser svg {fill: rgba(204,204,204,.8);width:1.875rem;height:1.875rem; padding: 0 7px;} .abstractIconButtonParser:hover svg{fill: #333;}</style><a href="https://github.com/breck7/pldb/blob/main/concepts/literate-coffeescript.scroll" class="doNotPrint abstractIconButtonParser" style="right:2rem;"><svg xmlns="http://www.w3.org/2000/svg" width="92pt" height="92pt" viewBox="0 0 92 92"><path d="M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371"/></svg></a>
<div class="scrollSection"><h1 class="scrollTitle"><a href="literate-coffeescript.html">Literate CoffeeScript</a></h1>
</div>
<a class="trueBaseThemePreviousItem" href="eve.html">&lt;</a>
<a class="trueBaseThemeNextItem" href="matplotlib.html">&gt;</a>
<div class="scrollColumns" style="column-width:90ch;column-count:1;max-width:90ch;">
<div class="trueBaseThemeQuickLinks"><a href="https://coffeescript.org/#literate" class="material-symbols-outlined">home</a> <a href="https://github.com/jashkenas/coffeescript"><svg xmlns="http://www.w3.org/2000/svg" width="92pt" height="92pt" viewBox="0 0 92 92"><path d="M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371"/></svg></a> <a href="https://sdk.scroll.pub/designer#url%20https%3A%2F%2Fpldb.io%2Fpldb.parsers%0AprogramUrl%20https%3A%2F%2Fpldb.io%2Fconcepts%2Fliterate-coffeescript.scroll" class="material-symbols-outlined">edit</a></div>
<p class="scrollParagraph">Literate CoffeeScript is a <a href="../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22contains%22%2C%22data%22%3A%22tags%22%2C%22origData%22%3A%22tags%22%2C%22type%22%3A%22string%22%2C%22value%22%3A%5B%22pl%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D">programming language</a> created in <a href="../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222013%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D">2013</a> by <a href="../lists/creators.html#q=Jeremy%20Ashkenas">Jeremy Ashkenas</a>.</p>
<table class="scrollDashboard"><tr><td>#230<span>on PLDB</span></td>
<td>11<span>Years Old</span></td>
<td>8k<span><span title="Literate CoffeeScript repos on GitHub.">Repos</span></span></td></tr>
</table>
<div class="codeWithHeader"><div class="codeHeader">Download source code:</div><code class="scrollCodeBlock">git clone https://github.com/jashkenas/coffeescript</code></div>
<a href="https://coffeescript.org/#literate">Homepage</a> ¬∑ <a href="https://github.com/jashkenas/coffeescript">Source Code</a>
<p class="scrollParagraph">Besides being used as an ordinary programming language, CoffeeScript may also be written in ‚Äúliterate‚Äù mode. If you name your file with a .litcoffee extension, you can write it as a Markdown document ‚Äî a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown‚Äôs way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.</p>
<ul ><li >Tags: <a href='../lists/explorer.html#searchBuilder=%7B"criteria"%3A%5B%7B"condition"%3A"contains"%2C"data"%3A"tags"%2C"origData"%3A"tags"%2C"type"%3A"string"%2C"value"%3A%5B"pl"%5D%7D%5D%2C"logic"%3A"AND"%7D'>programming language</a></li>
<li >Literate CoffeeScript is developed on <a href="https://github.com/jashkenas/coffeescript">GitHub</a> and has 16,466 stars</li>
<li >There are at least 7,938 Literate CoffeeScript repos on <a href="https://github.com/search?q=language:Literate CoffeeScript">GitHub</a></li>
<li >Early development of Literate CoffeeScript happened in <a href="../lists/labs.html#q=https://github.com/jashkenas/coffeescript/issues">https://github.com/jashkenas/coffeescript/issues</a></li>
<li >Literate CoffeeScript is written in <a href="markdown.html">Markdown</a>, <a href="coffeescript.html">CoffeeScript</a>, <a href="html.html">HTML</a>, <a href="javascript.html">JavaScript</a>, <a href="css.html">CSS</a>, <a href="json.html">JSON</a>, <a href="svg.html">SVG</a>, <a href="yaml.html">YAML</a>, <a href="xml.html">XML</a></li>
<li >GitHub supports <a href="https://github.com/atom/language-coffee-script" title="The package used for syntax highlighting by GitHub Linguist.">syntax highlighting</a> for Literate CoffeeScript</li>
<li ><a href="https://coffeescript.org/#literate">coffeescript.org</a> was registered in 2009</li>
<li >Read more about Literate CoffeeScript on the web: <a href="https://news.ycombinator.com/item?id=5277916">1.</a></li></ul>
<br>
<div class="codeWithHeader"><div class="codeHeader">Example from <a href='https://github.com/atom/language-coffee-script'>Linguist</a>:</div><code class="scrollCodeBlock">The **Scope** class regulates lexical scoping within CoffeeScript. As you
generate code, you create a tree of scopes in the same shape as the nested
function bodies. Each scope knows about the variables declared within it,
and has a reference to its parent enclosing scope. In this way, we know which
variables are new and need to be declared with `var`, and which are shared
with external scopes.

Import the helpers we plan to use.

    {extend, last} = require &#39;./helpers&#39;

    exports.Scope = class Scope

The `root` is the top-level **Scope** object for a given file.

      @root: null

Initialize a scope with its parent, for lookups up the chain,
as well as a reference to the **Block** node it belongs to, which is
where it should declare its variables, and a reference to the function that
it belongs to.

      constructor: (@parent, @expressions, @method) -&gt;
        @variables = [{name: &#39;arguments&#39;, type: &#39;arguments&#39;}]
        @positions = {}
        Scope.root = this unless @parent

Adds a new variable or overrides an existing one.

      add: (name, type, immediate) -&gt;
        return @parent.add name, type, immediate if @shared and not immediate
        if Object::hasOwnProperty.call @positions, name
          @variables[@positions[name]].type = type
        else
          @positions[name] = @variables.push({name, type}) - 1

When `super` is called, we need to find the name of the current method we&#39;re
in, so that we know how to invoke the same method of the parent class. This
can get complicated if super is being called from an inner function.
`namedMethod` will walk up the scope tree until it either finds the first
function object that has a name filled in, or bottoms out.

      namedMethod: -&gt;
        return @method if @method.name or !@parent
        @parent.namedMethod()

Look up a variable name in lexical scope, and declare it if it does not
already exist.

      find: (name) -&gt;
        return yes if @check name
        @add name, &#39;var&#39;
        no

Reserve a variable name as originating from a function parameter for this
scope. No `var` required for internal references.

      parameter: (name) -&gt;
        return if @shared and @parent.check name, yes
        @add name, &#39;param&#39;

Just check to see if a variable has already been declared, without reserving,
walks up to the root scope.

      check: (name) -&gt;
        !!(@type(name) or @parent?.check(name))

Generate a temporary variable name at the given index.

      temporary: (name, index) -&gt;
        if name.length &gt; 1
          &#39;_&#39; + name + if index &gt; 1 then index - 1 else &#39;&#39;
        else
          &#39;_&#39; + (index + parseInt name, 36).toString(36).replace /\d/g, &#39;a&#39;

Gets the type of a variable.

      type: (name) -&gt;
        return v.type for v in @variables when v.name is name
        null

If we need to store an intermediate result, find an available name for a
compiler-generated variable. `_var`, `_var2`, and so on...

      freeVariable: (name, reserve=true) -&gt;
        index = 0
        index++ while @check((temp = @temporary name, index))
        @add temp, &#39;var&#39;, yes if reserve
        temp

Ensure that an assignment is made at the top of this scope
(or at the top-level scope, if requested).

      assign: (name, value) -&gt;
        @add name, {value, assigned: yes}, yes
        @hasAssignments = yes

Does this scope have any declared variables?

      hasDeclarations: -&gt;
        !!@declaredVariables().length

Return the list of variables first declared in this scope.

      declaredVariables: -&gt;
        realVars = []
        tempVars = []
        for v in @variables when v.type is &#39;var&#39;
          (if v.name.charAt(0) is &#39;_&#39; then tempVars else realVars).push v.name
        realVars.sort().concat tempVars.sort()

Return the list of assignments that are supposed to be made at the top
of this scope.

      assignedVariables: -&gt;
        &quot;#{v.name} = #{v.type.value}&quot; for v in @variables when v.type.assigned</code></div>
<div class="scrollSection"><h2 class="scrollParagraph">Language <a href="../lists/features.html">features</a></h2>
</div>
<table id="table577" class="scrollTable">
 <thead><tr><th>Feature</th>

<th>Supported</th>

<th>Example</th>

<th>Token</th>
</tr></thead>
 <tbody><tr><td><a href="../features/hasSemanticIndentation.html">Semantic Indentation</a></td>
<td><span class="hasFeature">‚úì</span></td>
<td></td>
<td></td>
</tr></tbody>
 </table>
<div class="scrollKeyboardNav" style="display:none;"><a href="eve.html">eve.html</a> ¬∑ literate-coffeescript.html ¬∑ <a href="matplotlib.html">matplotlib.html</a><script>document.addEventListener('keydown', function(event) {
  if (document.activeElement !== document.body) return
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return // dont interfere with keyboard back button shortcut
  const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
  if (event.key === "ArrowLeft")
    getLinks()[0].click()
  else if (event.key === "ArrowRight")
    getLinks()[1].click()
 });</script></div>
</div>
<div class="abstractTextLinkParser"><a href="https://github.com/breck7/pldb/blob/main/concepts/literate-coffeescript.scroll">View source</a></div>
<script>
document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
 {
  if (!navigator.clipboard) return
  const button = document.createElement("span")
  button.classList.add("scrollCopyButton")
  block.appendChild(button)
  button.addEventListener("click", async () => {
    await navigator.clipboard.writeText(block.innerText)
    button.classList.add("scrollCopiedButton")
  })
 }
))
</script>


<div class="trueBaseThemeFooter">
 <a href="../index.html" class="trueBaseThemeLogo">PLDB</a>
 <span>- Build the next great programming language</span>
 <span>¬∑</span>
 <a href="../pages/about.html">About</a>
 <span>¬∑</span>
 <a href="../lists/keywords.html">Keywords</a>
 <span>¬∑</span>
 <a href="../lists/live.html">Livestreams</a>
 <span>¬∑</span>
 <a href="../lists/labs.html">Labs</a>
 <span>¬∑</span>
 <a href="../lists/resources.html">Resources</a>
 <span>¬∑</span>
 <a href="../pages/acknowledgements.html">Acknowledgements</a>
 <span>¬∑</span>
 <a href="https://wws.scroll.pub">Part of the World Wide Scroll</a>
</div>

<script src="../lists/autocompleteCombined.js"></script>
<script>document.addEventListener("DOMContentLoaded", evt => initAutocomplete("trueBaseThemeHeaderSearch"))</script>
</body>
</html>