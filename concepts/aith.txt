Aith
====

Aith is a programming language created in 2020 by Superstar64.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222020%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D 2020
 https://pldb.io/concepts/../lists/creators.html#q=Superstar64 Superstar64

#1618 on PLDB
4 Years Old

git clone https://github.com/Superstar64/aith

Aith is a perfomant systems programming language with am empathises on type systems. As of now Aith is very early stages and very little is implemented.

- Tags: programming language
- Aith is developed on GitHub and has 41 stars
- Early development of Aith happened in https://github.com/Superstar64/aith
- Aith is written in Haskell, Tex, Make, Markdown, Python, XML

module ::

inline runtimeCall = \f =&gt; \x =&gt; f (x);

module combinators = {
    inline flip = \f =&gt; \x =&gt; \y =&gt; f !y !x;
    inline compose = \f =&gt; \g =&gt; \x =&gt; f !(g !x);
    
    inline readerPure = \x =&gt; \r =&gt; x;
    inline readerBind = \m =&gt; \f =&gt; \r =&gt; f !(m !r) !r;
    inline readerMap = \f =&gt; \m =&gt; readerBind !m !(compose !readerPure !f);
};

module systemf = {
    inline ignored &lt;B : type&gt; : &lt;A : type&gt; B -&gt; B;
    inline ignored &lt;B : type&gt; = &lt;A : type&gt; \(x : B) =&gt; x;

    inline idSysF = &lt;A : type&gt; \x : A =&gt; x;

    inline runIdSysF = \f {
        |&lt; f : &lt;A : type&gt; A -&gt; A &gt;|
    };

    inline id = runIdSysF !idSysF;

    type natural = &lt;A : type&gt; A -&gt; (A -&gt; A) -&gt; A;

    inline zero&lt;&gt; : natural;
    inline zero = &lt;A : type&gt; \z : A =&gt; \inc : A -&gt; A =&gt; z;

    inline inc&lt;&gt; : natural -&gt; natural;
    inline inc = \n =&gt; &lt;A : type&gt; \z : A =&gt; \inc : A -&gt; A =&gt; inc !(|&lt; n : natural &gt;| !z !inc);

    inline one&lt;&gt; : natural;
    inline one = inc !zero;

    inline two&lt;&gt; : natural;
    inline two = inc !one;
};

module varSub = {
    inline sub&lt;R : pretype&lt;pointer, unrestricted&gt;, A : region, B : region &gt;= A, C:type&gt;
    : R in A -&gt; R in B -&gt; C -[linear]&gt; C;
    inline sub = \a =&gt; \b =&gt; \x =&gt; x;

    inline cycle = \a =&gt; \b =&gt; \c {
        sub !a !b !(
            sub !b !c !(
                sub !c !a !(
                    \x =&gt; x
                )
            )
        )
    };
};

module default = {
    add = function(x,y) {
        x + y
    };

    ambigous = function(x) {
        inline y = 1;
        x
    };
};

module unit = {
    idUnit = function () {
        ()
    };
};

module boolean = {
    inline yes = true;

    branch = function(b) {
        if b {
            1
        } else {
            2
        }
    };

    complex = function(b) {
        if (if (b) { true } else {false} ) {
            1
        } else {
            if yes {
                2
            } else {
                4
            }
        }
    };

    not = function(b) {
        !b
    };

    inBounds = function(x1, x2, x3) {
        x1 &lt;= x2 &amp; x2 &lt; x3
    };
};

module pair = {
    fst = function(x, y) =&gt; x;

    snd = function(x, y) =&gt; y;
    
    pattern = function (pair) {
        (fst(pair), snd(pair))
    };
};

module ptr = {
    derefTriple = function(x) {
        ***x
    };

    deref &lt;RA : region, RB : region &gt;= RA, T : pretype&lt;pointer, unrestricted&gt;&gt; : function (T* @ RA) =&gt; T uses RB;
    deref &lt;RA : region, RB : region &gt;= RA, T : pretype&lt;pointer, unrestricted&gt;&gt; = function (x) {
        *x
    };

    write&lt;A:region, B:region &gt;= A&gt; : function(int* @ A) =&gt; () uses B;
    write&lt;A:region, B:region &gt;= A&gt; = function(x :: int* @ A) {
        *x = (1 :: int)
    };

    writeTriple = function(x) {
        ***x = 1
    };

    swap = function(x,y) {
        let xp = *x;
        *x = (*y);
        *y = xp;
        ()
    };
};

module number = {
    type point = (int, int, int);

    dotProduct &lt;R : region&gt; : function(point, point) =&gt; int uses R;
    dotProduct = function((x1,y1,z1), (x2, y2, z2)) {
        (x1 * x2 + y1 * y2 + z1 * z2)
    };
  
    mid &lt;R : region&gt; : function(uint, uint) =&gt; uint uses R;
    mid &lt;R : region&gt; = function(x,y) {
        (x + y) / 2
    };

    inline divGen = function(x,y) {
        (x + y - 1) / y
    };

    div = divGen;

    lessEqual = function(x,y) {
        x &lt;= y
    };

    factorial&lt;R : region&gt; : function(ulong) =&gt; ulong uses R;
    factorial&lt;R : region&gt; = function(x) {
        if (x == 0) {
            1
        } else {
            x * factorial (x - 1)
        }
    };
};

module fptr = {
    call = function(f) {
        f (1)
    };

    callUnit &lt;R : region&gt; : function(function*(uint) =&gt; () uses R) =&gt; () uses R;
    callUnit &lt;R : region&gt; = function(f) {
        f (2)
    };
};

module recurse = {
    explode&lt;L : multiplicity, R:region, A:pretype&lt;pointer, L&gt;&gt; : function() =&gt; A uses R;
    explode&lt;L : multiplicity, R:region, A:pretype&lt;pointer, L&gt;&gt; = function() {
        explode ()
    };
};

module world = {
    inline putchar&lt;A:region&gt; : function*(int) =&gt; int uses io in A;
    inline putchar&lt;A:region&gt; = extern &quot;putchar&quot;;

    putPtr&lt;A:region &gt;= io&gt; : function(int* @ A) =&gt; int uses A;
    putPtr = function(ptr) {
        putchar (*ptr)
    };
};
module arrays = {
    inline get = \x =&gt; \i {
        * &amp;* &amp;x[i]
    };

    inline set = \x =&gt; \i =&gt; \a {
        * &amp;* &amp;x[i] = a
    };

    swap = function(a, b, i) {
        let tmp = get !a !i;
        set !a !i !(get !b !i);
        set !b !i !tmp;
        ()
    };

    memcpyPtr = function(dst, src, i) {
        loop (let (dst, src, i) = (dst, src, i)) {
            if(i != 0) {
                * &amp;* dst = (* &amp;* src);
                continue (&amp;dst[1], &amp;src[1], i - 1)
            } else {
                break ()
            }
        }
    };
};

module sort = {

    inline get = /arrays/get;

    inline set = /arrays/set;

    insert&lt;R : region&gt; : function(int[] @ R, unsigned integer(native)) =&gt; () uses R;
    insert&lt;R : region&gt; = function(array, index) {
        loop (let (array, index) = (array,index)) {
            if (index &gt; 0 &amp; get !array !index &lt; get !array !(index - 1) ) {
                let tmp = get !array !index;
                set !array !index !(get !array !(index - 1));
                set !array !(index - 1) !tmp;
                continue (array, index - 1)
            } else {
                break ()
            }
        }
    };

    sort &lt;R : region&gt; : function(int[] @ R, unsigned integer(native)) =&gt; () uses R;
    sort &lt;R : region&gt; = function(array, length) {
        if (length &gt; 1) {
            sort(array, length - 1);
            insert(array, length - 1)
        } else {
            ()
        }
    };
};

module borrowed = {
    increment &lt;R : region&gt; : function(unique int*) =&gt; unique int* uses R;
    increment &lt;R : region&gt; = function(p :: unique int*) {
        let ((), p) = borrow p as &lt;A : region &gt;= R&gt;(x :: int* @ A) {
            *x = (*x + 1)
        };
        p
    };
};

module partial = {
    inline auto = \x =&gt; x;
    
    inline semi&lt;A : type&gt; = \x : A =&gt; x;

    inline scoped&lt;A : type&gt; : A -&gt; A;
    inline scoped = \x : A =&gt; x;

    inline manual&lt;A : type&gt; : A -&gt; A;
    inline manual&lt;A : type&gt; = \x =&gt; x;
};

module import = {
    inline id = \x =&gt; x;
    module b = {
        inline const = \y =&gt; /import/id;
    };
};

module levity = {
    idPolyPair&lt;A : pretype&lt;struct(pointer, 32bit word) ,linear&gt;&gt; = function(x :: A) {
        x
    };

    idPolyUnion&lt;A : pretype&lt;union(pointer, 32bit word) ,linear&gt;&gt; = function(x :: A) {
        x
    };

    useId = function(ptr) {
        idPolyPair(ptr, 0)
    };
};

module sum = {
    triangular = function(start, end) {
        loop (let (i, total) = (start, 0)) {
            if (i &lt;= end) {
                continue (i + 1, total + i)
            } else {
                break (total)
            }
        }
    };
};

module newtype = {
    wrapper num : pretype&lt;32bit word, unrestricted&gt;;
    wrapper num = int;

    makeNum = function() {
        wrap 1 :: num
    };

    wrapper linked : pretype&lt;pointer, unrestricted&gt;;
    wrapper linked = linked2* @ io;

    type linked2 = linked;

    read = function (x) {
        *unwrap (x :: linked)
    };
};

as bool borrow boxed break byte capacity continue copy else existence extern false function if in inline int integer invariant io kind let linear long loop module multiarg multiplicity native opaque pointer pretype region representation short signed signedness size step struct subtypable transparent true type ubyte uint ulong union unique unrestricted unsigned unwrap used uses ushort word wrap wrapper
