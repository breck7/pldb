<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <title>stella - Programming language</title>
 <script>/* This HTML was generated by ðŸ“œ Scroll v136.3.0. https://scroll.pub */</script>
 <style>@media print {.doNotPrint {display: none !important;}}</style>
 <link rel="canonical" href="https://pldb.io/concepts/stella.html">
 <meta name="viewport" content="width=device-width,initial-scale=1">
 <meta name="description" content="STELLA is a strongly typed, object-oriented, Lisp-like language, designed to facilitate symbolic programming tasks in artificial intelligence applications. STELLA preserves those features of Common Lisp deemed essential for symbolic programming such as built-in support for dynamic data structures, heterogeneous collections, first-class symbols, powerful iteration constructs, name spaces, an object-oriented type system with a meta-object protocol, exception handling, and language extensibility through macros, but without compromising execution speed, interoperability with non-STELLA programs, and platform independence. STELLA programs are translated into a target language such as C++, Common Lisp, or Java, and then compiled with the native target language compiler to generate executable code. The language constructs of STELLA are restricted to those that can be translated directly into native constructs of the intended target languages, thus enabling the generation of highly efficient as well as readable code. As of Fall 2000, we have programmed approximately 100,000 lines of STELLA code - about 50% for the STELLA kernel itself and the other 50% for the PowerLoom knowledge representation system and related systems. Our subjective experience has been that it is only slightly more difficult to write and debug a STELLA program than a Lisp program, and that the inconvenience of having to supply some type information is much outweighed by the benefits such as catching many errors during compile time instead of at run time. The biggest benefit, however, seems to be that we can still leverage all the incremental code development benefits of Lisp, since we use the Common Lisp-based version of STELLA for prototyping. This allows us to incrementally define and redefine functions, methods and classes and to inspect, debug and fix incorrect code on the fly. Even the most sophisticated C++ or Java IDE's don't yet seem to support this fully incremental development style, i.e., a change in a class (every change in Java is a change to a class) still requires recompilation and restart of the application, and it is the restart that can be the most time consuming if one debugs a complex application that takes a significant time to reach a certain state.">
 <meta name="generator" content="Scroll v136.3.0">
 <meta property="og:title" content="stella - Programming language">
 <meta property="og:description" content="STELLA is a strongly typed, object-oriented, Lisp-like language, designed to facilitate symbolic programming tasks in artificial intelligence applications. STELLA preserves those features of Common Lisp deemed essential for symbolic programming such as built-in support for dynamic data structures, heterogeneous collections, first-class symbols, powerful iteration constructs, name spaces, an object-oriented type system with a meta-object protocol, exception handling, and language extensibility through macros, but without compromising execution speed, interoperability with non-STELLA programs, and platform independence. STELLA programs are translated into a target language such as C++, Common Lisp, or Java, and then compiled with the native target language compiler to generate executable code. The language constructs of STELLA are restricted to those that can be translated directly into native constructs of the intended target languages, thus enabling the generation of highly efficient as well as readable code. As of Fall 2000, we have programmed approximately 100,000 lines of STELLA code - about 50% for the STELLA kernel itself and the other 50% for the PowerLoom knowledge representation system and related systems. Our subjective experience has been that it is only slightly more difficult to write and debug a STELLA program than a Lisp program, and that the inconvenience of having to supply some type information is much outweighed by the benefits such as catching many errors during compile time instead of at run time. The biggest benefit, however, seems to be that we can still leverage all the incremental code development benefits of Lisp, since we use the Common Lisp-based version of STELLA for prototyping. This allows us to incrementally define and redefine functions, methods and classes and to inspect, debug and fix incorrect code on the fly. Even the most sophisticated C++ or Java IDE's don't yet seem to support this fully incremental development style, i.e., a change in a class (every change in Java is a change to a class) still requires recompilation and restart of the application, and it is the restart that can be the most time consuming if one debugs a complex application that takes a significant time to reach a certain state.">
 <meta property="og:image" content="">
 
 <link rel="source" type="application/git" title="Source Code Repository" href="https://github.com/breck7/pldb">
 <link rel="alternate" type="application/rss+xml" title="stella - Programming language" href="../blog/feed.xml">
 <meta name="twitter:card" content="summary_large_image">
</head>
<body>
<link rel="stylesheet" type="text/css" href="../gazette.css"></link>
<link rel="stylesheet" type="text/css" href="../TrueBaseTheme.css"></link>

<div class="trueBaseThemeHeader">
 <a href="../index.html" class="trueBaseThemeLogo">PLDB</a>
 <form style="display:inline-block;" method="get" action="../lists/explorer.html">
  <input type="search" id="trueBaseThemeHeaderSearch" name="q" placeholder="Search" autocomplete="off"></input>
</form>
 <a href="../lists/top1000.html">Top 1K</a>
 <a href="../lists/features.html">Features</a>
 <a href="../lists/creators.html">Creators</a>
 <a href="../lists/events.html">Events</a>
 <a href="../lists/podcasts.html">Podcasts</a>
 <a href="../books/index.html">Books</a>
 <a href="../lists/extensions.html">Extensions</a>
 <a href="../blog/interviews.html">Interviews</a>
 <a href="../blog/index.html">Blog</a>
 <a href="../lists/explorer.html">Explorer</a>
 <a href="../csv.html">CSV</a>
</div>

<style>.abstractIconButtonParser {position:absolute;top:0.25rem; }.abstractIconButtonParser svg {fill: rgba(204,204,204,.8);width:1.875rem;height:1.875rem; padding: 0 7px;} .abstractIconButtonParser:hover svg{fill: #333;}</style><a href="https://github.com/breck7/pldb/blob/main/concepts/stella.scroll" class="doNotPrint abstractIconButtonParser" style="right:2rem;"><svg xmlns="http://www.w3.org/2000/svg" width="92pt" height="92pt" viewBox="0 0 92 92"><path d="M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371"/></svg></a>
<div class="scrollSection"><h1 class="scrollTitle"><a href="stella.html">stella</a></h1>
</div>
<a class="trueBaseThemePreviousItem" href="sarl.html">&lt;</a>
<a class="trueBaseThemeNextItem" href="sweet-expressions.html">&gt;</a>
<div class="scrollColumns" style="column-width:90ch;column-count:1;max-width:90ch;">
<div class="trueBaseThemeQuickLinks"><a href="https://www.isi.edu/isd/LOOM/Stella/index.html" class="material-symbols-outlined">home</a> <a href="https://sdk.scroll.pub/designer#url%20https%3A%2F%2Fpldb.io%2Fpldb.parsers%0AprogramUrl%20https%3A%2F%2Fpldb.io%2Fconcepts%2Fstella.scroll" class="material-symbols-outlined">edit</a></div>
<p class="scrollParagraph">stella is a <a href="../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22contains%22%2C%22data%22%3A%22tags%22%2C%22origData%22%3A%22tags%22%2C%22type%22%3A%22string%22%2C%22value%22%3A%5B%22pl%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D">programming language</a> created in <a href="../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%221999%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D">1999</a>.</p>
<table class="scrollDashboard"><tr><td>#1982<span>on PLDB</span></td>
<td>25<span>Years Old</span></td></tr>
</table>
<a href="https://www.isi.edu/isd/LOOM/Stella/index.html">Homepage</a>
<p class="scrollParagraph">STELLA is a strongly typed, object-oriented, Lisp-like language, designed to facilitate symbolic programming tasks in artificial intelligence applications. STELLA preserves those features of Common Lisp deemed essential for symbolic programming such as built-in support for dynamic data structures, heterogeneous collections, first-class symbols, powerful iteration constructs, name spaces, an object-oriented type system with a meta-object protocol, exception handling, and language extensibility through macros, but without compromising execution speed, interoperability with non-STELLA programs, and platform independence. STELLA programs are translated into a target language such as C++, Common Lisp, or Java, and then compiled with the native target language compiler to generate executable code. The language constructs of STELLA are restricted to those that can be translated directly into native constructs of the intended target languages, thus enabling the generation of highly efficient as well as readable code. As of Fall 2000, we have programmed approximately 100,000 lines of STELLA code - about 50% for the STELLA kernel itself and the other 50% for the PowerLoom knowledge representation system and related systems. Our subjective experience has been that it is only slightly more difficult to write and debug a STELLA program than a Lisp program, and that the inconvenience of having to supply some type information is much outweighed by the benefits such as catching many errors during compile time instead of at run time. The biggest benefit, however, seems to be that we can still leverage all the incremental code development benefits of Lisp, since we use the Common Lisp-based version of STELLA for prototyping. This allows us to incrementally define and redefine functions, methods and classes and to inspect, debug and fix incorrect code on the fly. Even the most sophisticated C++ or Java IDE's don't yet seem to support this fully incremental development style, i.e., a change in a class (every change in Java is a change to a class) still requires recompilation and restart of the application, and it is the restart that can be the most time consuming if one debugs a complex application that takes a significant time to reach a certain state.</p>
<ul ><li >Tags: <a href='../lists/explorer.html#searchBuilder=%7B"criteria"%3A%5B%7B"condition"%3A"contains"%2C"data"%3A"tags"%2C"origData"%3A"tags"%2C"type"%3A"string"%2C"value"%3A%5B"pl"%5D%7D%5D%2C"logic"%3A"AND"%7D'>programming language</a></li>
<li >Early development of stella happened in <a href="../lists/labs.html#q=USC">USC</a></li></ul>
<br>
<div class="codeWithHeader"><div class="codeHeader">Example from the web:</div><code class="scrollCodeBlock">(defun (lisp-null-array-symbol-string STRING) ((rank INTEGER))
  ;; Used in the lisp translation code, insdie a verbatim
  ;; to return Lisp-specific-code.
  (CASE rank
    (1 (return &quot;STELLA::NULL-1D-ARRAY&quot;))
    (2 (return &quot;STELLA::NULL-2D-ARRAY&quot;))
    (3 (return &quot;STELLA::NULL-3D-ARRAY&quot;))
    (4 (return &quot;STELLA::NULL-4D-ARRAY&quot;))
    (5 (return &quot;STELLA::NULL-5D-ARRAY&quot;))
    (otherwise (return &quot;STELLA::NULL&quot;))))</code></div>
<div class="scrollSection"><h2 class="scrollParagraph">Language <a href="../lists/features.html">features</a></h2>
</div>
<table id="table167" class="scrollTable">
 <thead><tr><th>Feature</th>

<th>Supported</th>

<th>Example</th>

<th>Token</th>
</tr></thead>
 <tbody><tr><td><a href="../features/hasComments.html">Comments</a></td>
<td><span class="hasFeature">âœ“</span></td>
<td>
; A comment</td>
<td></td>
</tr>
<tr><td><a href="../features/hasLineComments.html">Line Comments</a></td>
<td><span class="hasFeature">âœ“</span></td>
<td>
; A comment</td>
<td>;</td>
</tr>
<tr><td><a href="../features/hasSemanticIndentation.html">Semantic Indentation</a></td>
<td><span class="doesNotHaveFeature">X</span></td>
<td></td>
<td></td>
</tr></tbody>
 </table>
<div class="scrollKeyboardNav" style="display:none;"><a href="sarl.html">sarl.html</a> Â· stella.html Â· <a href="sweet-expressions.html">sweet-expressions.html</a><script>document.addEventListener('keydown', function(event) {
  if (document.activeElement !== document.body) return
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return // dont interfere with keyboard back button shortcut
  const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
  if (event.key === "ArrowLeft")
    getLinks()[0].click()
  else if (event.key === "ArrowRight")
    getLinks()[1].click()
 });</script></div>
</div>
<div class="abstractTextLinkParser"><a href="https://github.com/breck7/pldb/blob/main/concepts/stella.scroll">View source</a></div>
<script>
document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
 {
  if (!navigator.clipboard) return
  const button = document.createElement("span")
  button.classList.add("scrollCopyButton")
  block.appendChild(button)
  button.addEventListener("click", async () => {
    await navigator.clipboard.writeText(block.innerText)
    button.classList.add("scrollCopiedButton")
  })
 }
))
</script>


<div class="trueBaseThemeFooter">
 <a href="../index.html" class="trueBaseThemeLogo">PLDB</a>
 <span>- Build the next great programming language</span>
 <span>Â·</span>
 <a href="../pages/about.html">About</a>
 <span>Â·</span>
 <a href="../lists/keywords.html">Keywords</a>
 <span>Â·</span>
 <a href="../lists/live.html">Livestreams</a>
 <span>Â·</span>
 <a href="../lists/labs.html">Labs</a>
 <span>Â·</span>
 <a href="../lists/resources.html">Resources</a>
 <span>Â·</span>
 <a href="../pages/acknowledgements.html">Acknowledgements</a>
 <span>Â·</span>
 <a href="https://wws.scroll.pub">Part of the World Wide Scroll</a>
</div>

<script src="../lists/autocompleteCombined.js"></script>
<script>document.addEventListener("DOMContentLoaded", evt => initAutocomplete("trueBaseThemeHeaderSearch"))</script>
</body>
</html>