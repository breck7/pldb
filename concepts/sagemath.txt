Sage
====

Sage is an open source programming language created in 2005.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222005%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D 2005

#359 on PLDB
19 Years Old
499 Repos

SageMath (previously Sage or SAGE, "System for Algebra and Geometry Experimentation") is a mathematical software with features covering many aspects of mathematics, including algebra, combinatorics, numerical mathematics, number theory, and calculus. The first version of SageMath was released on 24 February 2005 as free and open-source software under the terms of the GNU General Public License version 2, with the initial goals of creating an "open source alternative to Magma, Maple, Mathematica, and MATLAB". The originator and leader of the SageMath project, William Stein, is a mathematician at the University of Washington. Read more on Wikipedia...
 https://en.wikipedia.org/wiki/SageMath Read more on Wikipedia...

- Tags: programming language
- There are at least 499 Sage repos on GitHub
- Early development of Sage happened in University of Washington
- The  Google BigQuery Public Dataset GitHub snapshot shows 83 users using Sage in 84 repos on GitHub
- There are 312 Project Euler users using Sage
- GitHub supports syntax highlighting for Sage
- There is 1 Jupyter Kernel for Sage
- sagemath.org was registered in 2007
- See also: (24 related languages) Python, Cython, Linux, Solaris, Android, iOS, IA-32, ARM, SPARC, Maple, Mathematica, MATLAB, Maxima, SciPy, NumPy, R, LaTeX, SQL, Fortran, C, Common Lisp, PARI/GP, SQLite, Matplotlib

print(&quot;Hello, world!&quot;)

# -*- coding: utf-8 -*-
#
#   Funciones en Python/Sage para el trabajo con polinomios con una
#   incógnita (x).
#
#   Copyright (C) 2014-2015, David Abián &lt;davidabian [at] davidabian.com&gt;
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the Free
#   Software Foundation, either version 3 of the License, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#   more details.
#
#   You should have received a copy of the GNU General Public License along with
#   this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

def pols (grado=-1, K=GF(2), mostrar=False):
    &quot;&quot;&quot;Devuelve la lista de polinomios constantes y no constantes de
    coeficientes mónicos y grado igual o menor que el especificado.
    Si el grado indicado no es válido, devuelve una lista vacía.
    &quot;&quot;&quot;
    lpols = []
    if not grado.is_integer():
        grado = grado.round()
    if grado &gt;= 0:
        var(&#39;x&#39;)
        xs = vector([(x^i) for i in range(grado+1)])
        V = VectorSpace(K,grado+1)
        lpols = [cs*xs for cs in V]
        if mostrar:
            for pol in lpols:
                print pol
    return lpols

def polsNoCtes (grado=-1, K=GF(2), mostrar=False):
    &quot;&quot;&quot;Devuelve la lista de polinomios no constantes de coeficientes mónicos y
    grado igual o menor que el especificado.
    Si el grado indicado no es válido, devuelve una lista vacía.
    &quot;&quot;&quot;
    lpols = []
    if not grado.is_integer():
        grado = grado.round()
    if grado &gt;= 0:
        var(&#39;x&#39;)
        xs = vector([(x^i) for i in range(grado+1)])
        for cs in K^(grado+1):
            if cs[:grado] != vector(grado*[0]): # no constantes
                lpols += [cs*xs]
        if mostrar:
            for pol in lpols:
                print pol
    return lpols

def polsMismoGrado (grado=-1, K=GF(2), mostrar=False):
    &quot;&quot;&quot;Devuelve la lista de polinomios de coeficientes mónicos del grado
    especificado.
    Si el grado indicado no es válido, devuelve una lista vacía.
    &quot;&quot;&quot;
    lpols = []
    if not grado.is_integer():
        grado = grado.round()
    if grado &gt;= 0:
        var(&#39;x&#39;)
        xs = vector([(x^(grado-i)) for i in [0..grado]])
        for cs in K^(grado+1):
            if cs[0] != 0: # polinomios del mismo grado
                lpols += [cs*xs]
        if mostrar:
            for pol in lpols:
                print pol
    return lpols

def excluirReducibles (lpols=[], mostrar=False):
    &quot;&quot;&quot;Filtra una lista dada de polinomios de coeficientes mónicos y devuelve
    aquellos irreducibles.
    &quot;&quot;&quot;
    var(&#39;x&#39;)
    irreds = []
    for p in lpols:
        fp = (p.factor_list())
        if len(fp) == 1 and fp[0][1] == 1:
            irreds += [p]
    if mostrar:
        for pol in irreds:
            print pol
    return irreds

def vecPol (vec=random_vector(GF(2),0)):
    &quot;&quot;&quot;Transforma los coeficientes dados en forma de vector en el polinomio
    que representan.
    
    Por ejemplo, con vecPol(vector([1,0,3,1])) se obtiene x³ + 3*x + 1.
    
    Para la función opuesta, véase polVec().
    &quot;&quot;&quot;
    var(&#39;x&#39;)
    xs = vector([x^(len(vec)-1-i) for i in range(len(vec))])
    return vec*xs

def polVec (p=None):
    &quot;&quot;&quot;Devuelve el vector de coeficientes del polinomio dado que acompañan a la
    incógnita x, de mayor a menor grado.
    
    Por ejemplo, con polVec(x^3 + 3*x + 1) se obtiene el vector (1, 0, 3, 1).
    
    Para la función opuesta, véase vecPol().
    &quot;&quot;&quot;
    cs = []
    if p != None:
        var(&#39;x&#39;)
        p(x) = p
        for i in [0..p(x).degree(x)]:
            cs.append(p(x).coefficient(x,i))
        cs = list(reversed(cs))
    return vector(cs)

def completar2 (p=0):
    &quot;&quot;&quot;Aplica el método de completar cuadrados en parábolas al polinomio dado de
    grado 2 y lo devuelve en su nueva forma.
    
    Si el polinomio dado no es válido, devuelve 0.
    
    Por ejemplo, con complCuad(3*x^2 + 12*x + 5) se obtiene 3*(x + 2)^2 - 7.
    &quot;&quot;&quot;
    var(&#39;x&#39;)
    p(x) = p.expand()
    if p(x).degree(x) != 2:
        p(x) = 0
    else:
        cs = polVec(p(x))
        p(x) = cs[0]*(x+(cs[1]/(2*cs[0])))^2+(4*cs[0]*cs[2]-cs[1]^2)/(4*cs[0])
    return p(x)

sage: E2 = EllipticCurve(CC, [0,0,-2,1,1])
sage: E2
Elliptic Curve defined by y^2 + (-2.00000000000000)*y =
         x^3 + 1.00000000000000*x + 1.00000000000000 over
         Complex Field with 53 bits of precision
sage: E2.j_invariant()
61.7142857142857

Language features
======================================================

row
 Feature Comments
 FeatureLink ../features/hasComments.html
 Supported ✓
 Example
  # A comment
 Token 
row
 Feature Line Comments
 FeatureLink ../features/hasLineComments.html
 Supported ✓
 Example
  # A comment
 Token #
row
 Feature Case Insensitive Identifiers
 FeatureLink ../features/hasCaseInsensitiveIdentifiers.html
 Supported X
 Example
 Token 
row
 Feature Semantic Indentation
 FeatureLink ../features/hasSemanticIndentation.html
 Supported X
 Example
 Token
