import ../code/conceptPage.scroll

id protobuf
name Protocol Buffers
appeared 2008
tags idl
website https://developers.google.com/protocol-buffers/

isOpenSource true
clocExtensions proto
fileType text
docs https://developers.google.com/protocol-buffers/docs/overview
antlr https://github.com/antlr/grammars-v4/tree/master/protobuf3
monaco protobuf
originCommunity Google

pygmentsHighlighter Protocol Buffer
 filename dsls.py
 fileExtensions proto
example
 message Person {
   required string name = 1;
   required int32 id = 2;
   optional string email = 3;
 }

keywords syntax import weak public package option repeated oneof map reserved to max enum message service rpc stream returns package optional true false

lineCommentToken //
multiLineCommentTokens /* */
booleanTokens true false

hasLineComments true
 // A comment
hasComments true
 // A comment
hasSemanticIndentation false
hasStrings true
hasMultiLineComments true
 /* A comment
 */
hasBooleans true
hasAccessModifiers true
hasOctals true
 // 0[0-7]+[LlUu]*
hasHexadecimals true
 // 0x[0-9a-fA-F]+[LlUu]*
hasFloats true
 // (\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[LlUu]*
hasIntegers true
 // \d+[LlUu]*

wikipedia https://en.wikipedia.org/wiki/Protocol_Buffers
 example
  // polyline.cpp
  #include "polyline.pb.h"  // generated by calling "protoc polyline.proto"
  
  Line* createNewLine(const std::string& name) {
    // create a line from (10, 20) to (30, 40)
    Line* line = new Line;
    line->mutable_start()->set_x(10);
    line->mutable_start()->set_y(20);
    line->mutable_end()->set_x(30);
    line->mutable_end()->set_y(40);
    line->set_label(name);
    return line;
  }
  
  Polyline* createNewPolyline() {
    // create a polyline with points at (10,10) and (20,20)
    Polyline* polyline = new Polyline;
    Point* point1 = polyline->add_point();
    point1->set_x(10);
    point1->set_y(10);
    Point* point2 = polyline->add_point();
    point2->set_x(20);
    point2->set_y(20);
    return polyline;
  }
 related xml thrift java csharp python go ruby objective-c perl php scala julia
 summary Protocol Buffers is a method of serializing structured data. It is useful in developing programs to communicate with each other over a wire or for storing data. The method involves an interface description language that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data. Google developed Protocol Buffers for use internally and has provided a code generator for multiple languages under an open source license (see below). The design goals for Protocol Buffers emphasized simplicity and performance. In particular, it was designed to be smaller and faster than XML. Protocol Buffers is widely used at Google for storing and interchanging all kinds of structured information. The method serves as a basis for a custom remote procedure call (RPC) system that is used for nearly all inter-machine communication at Google. Protocol Buffers are similar to the Apache Thrift (used by Facebook) or Microsoft Bond protocols, offering as well a concrete RPC protocol stack to use for defined services called gRPC. A software developer defines data structures (called messages) and services in a proto definition file (.proto) and compiles it with protoc. This compilation generates code that can be invoked by a sender or recipient of these data structures. For example, example.proto will produce example.pb.cc and example.pb.h, which will define C++ classes for each message and service that example.proto defines. Canonically, messages are serialized into a binary wire format which is compact, forward- and backward-compatible, but not self-describing (that is, there is no way to tell the names, meaning, or full datatypes of fields without an external specification). There is no defined way to include or refer to such an external specification (schema) within a Protocol Buffers file. The officially supported implementation includes an ASCII serialization format, but this format—though self-describing—loses the forward- and backward-compatibility behavior, and is thus not a good choice for applications other than debugging. Though the primary purpose of Protocol Buffers is to facilitate network communication, its simplicity and speed make Protocol Buffers an alternative to data-centric C++ classes and structs, especially where interoperability with other languages or systems might be needed in the future.
 pageId 18338104
 dailyPageViews 439
 created 2008
 backlinksCount 86
 revisionCount 218
 appeared 2001

githubBigQuery Protocol Buffer
 repos 11692
 users 10064

linguistGrammarRepo https://github.com/michaeledgar/protobuf-tmbundle
 firstCommit 2010
 lastCommit 2018
 committerCount 2
 commitCount 11
 sampleCount 1
 example
  package tutorial;
  
  option java_package = "com.example.tutorial";
  option java_outer_classname = "AddressBookProtos";
  
  message Person {
    required string name = 1;
    required int32 id = 2;
    optional string email = 3;
  
    enum PhoneType {
      MOBILE = 0;
      HOME = 1;
      WORK = 2;
    }
  
    message PhoneNumber {
      required string number = 1;
      optional PhoneType type = 2 [default = HOME];
    }
  
    repeated PhoneNumber phone = 4;
  }
  
  message AddressBook {
    repeated Person person = 1;
  }
  

githubLanguage Protocol Buffer
 fileExtensions proto
 trendingProjectsCount 0
 type data
 aceMode protobuf
 codemirrorMode protobuf
 codemirrorMimeType text/x-protobuf
 tmScope source.proto
 aliases protobuf or Protocol Buffers
 repos 23747

indeedJobs protocol buffers developer
 2022 94

semanticScholar 0
