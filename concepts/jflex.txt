JFlex
=====

JFlex is an open source grammar language created in 2003.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222003%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D

#435 on PLDB
21 Years Old
2 Repos

git clone https://github.com/jflex-de/jflex

JFlex is a lexical analyzer generator (also known as scanner generator) for Java, written in Java.

- Tags: grammarLanguage
- JFlex is developed on GitHub and has 469 stars
- There are at least 2 JFlex repos on GitHub
- Early development of JFlex happened in https://github.com/jflex-de/
- JFlex is written in Java, starlark, Markdown, Perl, Bourne shell, Velocity Template Language, XML, Make, YAML, Tex, CSS, Bash, JSON, Vim script, Lisp, Yacc, Bazel, ActionScript
- The  Google BigQuery Public Dataset GitHub snapshot shows 38 users using JFlex in 39 repos on GitHub
- GitHub supports syntax highlighting for JFlex

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright (C) 1998-2015  Gerwin Klein &lt;lsf@jflex.de&gt;                    *
 * All rights reserved.                                                    *
 *                                                                         *
 * License: BSD                                                            *
 *                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* Java 1.2 language lexer specification */

/* Use together with unicode.flex for Unicode preprocesssing */
/* and java12.cup for a Java 1.2 parser                      */

/* Note that this lexer specification is not tuned for speed.
   It is in fact quite slow on integer and floating point literals,
   because the input is read twice and the methods used to parse
   the numbers are not very fast.
   For a production quality application (e.g. a Java compiler)
   this could be optimized */

import java_cup.runtime.*;

%%

%public
%class Scanner
%implements sym

%unicode

%line
%column

%cup
%cupdebug

%{
  StringBuilder string = new StringBuilder();
  
  private Symbol symbol(int type) {
    return new JavaSymbol(type, yyline+1, yycolumn+1);
  }

  private Symbol symbol(int type, Object value) {
    return new JavaSymbol(type, yyline+1, yycolumn+1, value);
  }

  /**
   * assumes correct representation of a long value for
   * specified radix in scanner buffer from &lt;code&gt;start&lt;/code&gt;
   * to &lt;code&gt;end&lt;/code&gt;
   */
  private long parseLong(int start, int end, int radix) {
    long result = 0;
    long digit;

    for (int i = start; i &lt; end; i++) {
      digit  = Character.digit(yycharat(i),radix);
      result*= radix;
      result+= digit;
    }

    return result;
  }
%}

/* main character classes */
LineTerminator = \r|\n|\r\n
InputCharacter = [^\r\n]

WhiteSpace = {LineTerminator} | [ \t\f]

/* comments */
Comment = {Tradi

Language features
======================================================

row
 Feature Comments
 FeatureLink ../features/hasComments.html
 Supported ✓
 Example
  /* A comment
  */
 Token 
row
 Feature MultiLine Comments
 FeatureLink ../features/hasMultiLineComments.html
 Supported ✓
 Example
  /* A comment
  */
 Token /* */
row
 Feature Semantic Indentation
 FeatureLink ../features/hasSemanticIndentation.html
 Supported X
 Example
 Token
