Yedalog
=======

Yedalog is a query language created in 2015 by Brian Chin and Daniel von Dincklage and Vuk Ercegovac and Peter Hawkins and Mark S. Miller and Franz Och and Chris Olston and Fernando Pereira.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222015%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D 2015
 https://pldb.io/concepts/../lists/creators.html#q=Brian%20Chin Brian Chin
 https://pldb.io/concepts/../lists/creators.html#q=Daniel%20von%20Dincklage Daniel von Dincklage
 https://pldb.io/concepts/../lists/creators.html#q=Vuk%20Ercegovac Vuk Ercegovac
 https://pldb.io/concepts/../lists/creators.html#q=Peter%20Hawkins Peter Hawkins
 https://pldb.io/concepts/../lists/creators.html#q=Mark%20S.%20Miller Mark S. Miller
 https://pldb.io/concepts/../lists/creators.html#q=Franz%20Och Franz Och
 https://pldb.io/concepts/../lists/creators.html#q=Chris%20Olston Chris Olston
 https://pldb.io/concepts/../lists/creators.html#q=Fernando%20Pereira Fernando Pereira

#2360 on PLDB
9 Years Old

 We introduce Yedalog, a declarative programming language that allows programmers to mix data-parallel pipelines and computation seamlessly in a single language. By contrast, most existing tools for data-parallel computation embed a sublanguage of data-parallel pipelines in a general-purpose language, or vice versa. Yedalog extends Datalog, incorporating not only computational features from logic programming, but also features for working with data structured as nested records. Yedalog programs can run both on a single machine, and distributed across a cluster in batch and interactive modes, allowing programmers to mix different modes of execution easily.

- Tags: queryLanguage
- Early development of Yedalog happened in Google
- See also: (1 related languages) Datalog
- Read more about Yedalog on the web: 1.
 https://research.google/pubs/pub43462/ 1.

Documents = Load{path: &quot;document-parse-trees&quot;};

# Code to execute for each document:
module PerDocument{tokens: T} = {
# Computes parent-child relationships
Child{p} = c :- T[c] == {parent: p, .._};

# Computes nodes that transitively descend from &quot;influenced&quot;
Descendants{t: c} :- T[p] == {text: &quot;influenced&quot;, .._}, c == Child{p};
Descendants{t: c} :- Descendants{t: p}, c == Child{p};

# Counts nodes in which each entity appears under the verb &quot;influenced&quot;.
Influence{mid} += 1 :- Descendants{t}, T[t] == {entity: mid, .._};
};

# Each entity’s influence from each hostname
Influential{mid, hostname} += count :-
Documents{tokens, hostname, .._},
PerDocument{tokens}.Influence{mid} == count;

# Persists Influential as protocol buffer data
? Store{data: Influential, path: &quot;influential-entities&quot;};

Language features
======================================================

row
 Feature Comments
 FeatureLink ../features/hasComments.html
 Supported ✓
 Example
  # A comment
 Token 
row
 Feature Line Comments
 FeatureLink ../features/hasLineComments.html
 Supported ✓
 Example
  # A comment
 Token #
row
 Feature Semantic Indentation
 FeatureLink ../features/hasSemanticIndentation.html
 Supported X
 Example
 Token
