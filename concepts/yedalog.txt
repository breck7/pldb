Yedalog
=======

Yedalog is a query language created in 2015 by Brian Chin and Daniel von Dincklage and Vuk Ercegovac and Peter Hawkins and Mark S. Miller and Franz Och and Chris Olston and Fernando Pereira.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222015%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D
 https://pldb.io/concepts/../lists/creators.html#q=Brian%20Chin
 https://pldb.io/concepts/../lists/creators.html#q=Daniel%20von%20Dincklage
 https://pldb.io/concepts/../lists/creators.html#q=Vuk%20Ercegovac
 https://pldb.io/concepts/../lists/creators.html#q=Peter%20Hawkins
 https://pldb.io/concepts/../lists/creators.html#q=Mark%20S.%20Miller
 https://pldb.io/concepts/../lists/creators.html#q=Franz%20Och
 https://pldb.io/concepts/../lists/creators.html#q=Chris%20Olston
 https://pldb.io/concepts/../lists/creators.html#q=Fernando%20Pereira

#2343 on PLDB
9 Years Old

 We introduce Yedalog, a declarative programming language that allows programmers to mix data-parallel pipelines and computation seamlessly in a single language. By contrast, most existing tools for data-parallel computation embed a sublanguage of data-parallel pipelines in a general-purpose language, or vice versa. Yedalog extends Datalog, incorporating not only computational features from logic programming, but also features for working with data structured as nested records. Yedalog programs can run both on a single machine, and distributed across a cluster in batch and interactive modes, allowing programmers to mix different modes of execution easily.

- Yedalog first developed in Google
- Read more about Yedalog on the web: 1.
 https://research.google/pubs/pub43462/

Documents = Load{path: &quot;document-parse-trees&quot;};

# Code to execute for each document:
module PerDocument{tokens: T} = {
# Computes parent-child relationships
Child{p} = c :- T[c] == {parent: p, .._};

# Computes nodes that transitively descend from &quot;influenced&quot;
Descendants{t: c} :- T[p] == {text: &quot;influenced&quot;, .._}, c == Child{p};
Descendants{t: c} :- Descendants{t: p}, c == Child{p};

# Counts nodes in which each entity appears under the verb &quot;influenced&quot;.
Influence{mid} += 1 :- Descendants{t}, T[t] == {entity: mid, .._};
};

# Each entity’s influence from each hostname
Influential{mid, hostname} += count :-
Documents{tokens, hostname, .._},
PerDocument{tokens}.Influence{mid} == count;

# Persists Influential as protocol buffer data
? Store{data: Influential, path: &quot;influential-entities&quot;};

Language features
======================================================

row
 Feature Comments
 FeatureLink ../features/hasComments.html
 Supported ✓
 Token 
 Example
  # A comment
row
 Feature Line Comments
 FeatureLink ../features/hasLineComments.html
 Supported ✓
 Token #
 Example
  # A comment
row
 Feature Semantic Indentation
 FeatureLink ../features/hasSemanticIndentation.html
 Supported X
 Token 
 Example
