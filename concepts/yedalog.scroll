import ../code/conceptPage.scroll

id yedalog
name Yedalog
appeared 2015
creators Brian Chin and Daniel von Dincklage and Vuk Ercegovac and Peter Hawkins and Mark S. Miller and Franz Och and Chris Olston and Fernando Pereira
tags queryLanguage
description  We introduce Yedalog, a declarative programming language that allows programmers to mix data-parallel pipelines and computation seamlessly in a single language. By contrast, most existing tools for data-parallel computation embed a sublanguage of data-parallel pipelines in a general-purpose language, or vice versa. Yedalog extends Datalog, incorporating not only computational features from logic programming, but also features for working with data structured as nested records. Yedalog programs can run both on a single machine, and distributed across a cluster in batch and interactive modes, allowing programmers to mix different modes of execution easily.

relatedConcepts datalog
originCommunity Google
reference https://research.google/pubs/pub43462/

example
 Documents = Load{path: "document-parse-trees"};
 
 # Code to execute for each document:
 module PerDocument{tokens: T} = {
 # Computes parent-child relationships
 Child{p} = c :- T[c] == {parent: p, .._};
 
 # Computes nodes that transitively descend from "influenced"
 Descendants{t: c} :- T[p] == {text: "influenced", .._}, c == Child{p};
 Descendants{t: c} :- Descendants{t: p}, c == Child{p};
 
 # Counts nodes in which each entity appears under the verb "influenced".
 Influence{mid} += 1 :- Descendants{t}, T[t] == {entity: mid, .._};
 };
 
 # Each entityâ€™s influence from each hostname
 Influential{mid, hostname} += count :-
 Documents{tokens, hostname, .._},
 PerDocument{tokens}.Influence{mid} == count;
 
 # Persists Influential as protocol buffer data
 ? Store{data: Influential, path: "influential-entities"};

lineCommentToken #

hasLineComments true
 # A comment
hasComments true
 # A comment
hasSemanticIndentation false
