Oberon-2
========

Oberon-2 is a programming language created in 1991 by Niklaus Wirth and Hanspeter Mössenböck.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%221991%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D
 https://pldb.io/concepts/../lists/creators.html#q=Niklaus%20Wirth
 https://pldb.io/concepts/../lists/creators.html#q=Hanspeter%20M%C3%B6ssenb%C3%B6ck

#824 on PLDB
33 Years Old

Oberon-2 is an extension of the original Oberon programming language that adds limited reflection and object-oriented programming facilities, open arrays as pointer base types, read-only field export and reintroduces the FOR loop from Modula-2. It was developed in 1991 at ETH Zurich by Niklaus Wirth and Hanspeter Mössenböck, who is now at Institut für Systemsoftware (SSW) of the University of Linz, Austria.  Oberon-2 is a superset of Oberon, and is fully compatible with it. Read more on Wikipedia...
 https://en.wikipedia.org/wiki/Oberon-2

- Oberon-2 Wikipedia page
 https://en.wikipedia.org/wiki/Oberon-2
- Oberon-2 is a superset of Oberon
- Oberon-2 first developed in Eidgenössische Technische Hochschule Zürich
- Explore Oberon-2 snippets on Rosetta Code
- Oberon-2 on HOPL
 https://hopl.info/showlanguage.prx?exp=1647
- See also: (12 related languages)Oberon, Modula-2, Pascal, Go, Object Oberon, Smalltalk, Python, Java, Algol, Yacc, JavaScript, PowerPC
- Read more about Oberon-2 on Semantic Scholar: 1.
 https://semanticscholar.org/paper/0279ae521a3f0c16e53259cf62f83739931fbc50
- Read more about Oberon-2 on the web: 1.
 https://dl.acm.org/doi/pdf/10.1145/157352.157355
- 1 languages in PLDB linking to Oberon-2: COMPONENT PASCAL

MODULE HelloWorld;
IMPORT Out;
BEGIN
  Out.String( &quot;Hello World&quot; );
  Out.Ln;
END HelloWorld.

Module        = MODULE ident &quot;;&quot; [ImportList] DeclSeq [BEGIN StatementSeq] END ident &quot;.&quot;.
ImportList    = IMPORT [ident &quot;:=&quot;] ident {&quot;,&quot; [ident &quot;:=&quot;] ident} &quot;;&quot;.
DeclSeq       = { CONST {ConstDecl &quot;;&quot; } | TYPE {TypeDecl &quot;;&quot;} | VAR {VarDecl &quot;;&quot;}} {ProcDecl &quot;;&quot; | ForwardDecl &quot;;&quot;}.
ConstDecl     = IdentDef &quot;=&quot; ConstExpr.
TypeDecl      = IdentDef &quot;=&quot; Type.
VarDecl       = IdentList &quot;:&quot; Type.
ProcDecl      = PROCEDURE [Receiver] IdentDef [FormalPars] &quot;;&quot; DeclSeq [BEGIN StatementSeq] END ident.
ForwardDecl   = PROCEDURE &quot;^&quot; [Receiver] IdentDef [FormalPars].
FormalPars    = &quot;(&quot; [FPSection {&quot;;&quot; FPSection}] &quot;)&quot; [&quot;:&quot; Qualident].
FPSection     = [VAR] ident {&quot;,&quot; ident} &quot;:&quot; Type.
Receiver      = &quot;(&quot; [VAR] ident &quot;:&quot; ident &quot;)&quot;.
Type          = Qualident
              | ARRAY [ConstExpr {&quot;,&quot; ConstExpr}] OF Type
              | RECORD [&quot;(&quot;Qualident&quot;)&quot;] FieldList {&quot;;&quot; FieldList} END
              | POINTER TO Type
              | PROCEDURE [FormalPars].
FieldList     = [IdentList &quot;:&quot; Type].
StatementSeq  = Statement {&quot;;&quot; Statement}.
Statement     = [ Designator &quot;:=&quot; Expr
              | Designator [&quot;(&quot; [ExprList] &quot;)&quot;]
              | IF Expr THEN StatementSeq {ELSIF Expr THEN StatementSeq} [ELSE StatementSeq] END
              | CASE Expr OF Case {&quot;|&quot; Case} [ELSE StatementSeq] END
              | WHILE Expr DO StatementSeq END
              | REPEAT StatementSeq UNTIL Expr
              | FOR ident &quot;:=&quot; Expr TO Expr [BY ConstExpr] DO StatementSeq END
              | LOOP StatementSeq END
              | WITH Guard DO StatementSeq {&quot;|&quot; Guard DO StatementSeq} [ELSE StatementSeq] END
              | EXIT
              | RETURN [Expr]
      ].
Case          = [CaseLabels {&quot;,&quot; CaseLabels} &quot;:&quot; StatementSeq].
CaseLabels    = ConstExpr [&quot;..&quot; ConstExpr].
Guard         = Qualident &quot;:&quot; Qualident.
ConstExpr     = Expr.
Expr          = SimpleExpr [Relation SimpleExpr].
SimpleExpr    = [&quot;+&quot; | &quot;-&quot;] Term {AddOp Term}.
Term          = Factor {MulOp Factor}.
Factor        = Designator [&quot;(&quot; [ExprList] &quot;)&quot;] | number | character | string | NIL | Set | &quot;(&quot; Expr &quot;)&quot; | &quot; ~ &quot; Factor.
Set           = &quot;{&quot; [Element {&quot;,&quot; Element}] &quot;}&quot;.
Element       = Expr [&quot;..&quot; Expr].
Relation      = &quot;=&quot; | &quot;#&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; | IN | IS.
AddOp         = &quot;+&quot; | &quot;-&quot; | OR.
MulOp         = &quot;*&quot; | &quot;/&quot; | DIV | MOD | &quot;&amp;&quot;.
Designator    = Qualident {&quot;.&quot; ident | &quot;[&quot; ExprList &quot;]&quot; | &quot; ^ &quot; | &quot;(&quot; Qualident &quot;)&quot;}.
ExprList      = Expr {&quot;,&quot; Expr}.
IdentList     = IdentDef {&quot;,&quot; IdentDef}.
Qualident     = [ident &quot;.&quot;] ident.
IdentDef      = ident [&quot; * &quot; | &quot; - &quot;].

Language features
======================================================

row
 Feature Strings
 FeatureLink ../features/hasStrings.html
 Supported ✓
 Token "
 Example
  "Hello world"
row
 Feature Print() Debugging
 FeatureLink ../features/hasPrintDebugging.html
 Supported ✓
 Token Out.String
 Example
row
 Feature Comments
 FeatureLink ../features/hasComments.html
 Supported ✓
 Token 
 Example
row
 Feature Semantic Indentation
 FeatureLink ../features/hasSemanticIndentation.html
 Supported X
 Token 
 Example
