SIL
===

SIL, aka Swift Intermediate Language, is an intermediate representation language created in 2012.
 https://pldb.io/concepts/../lists/explorer.html#searchBuilder=%7B%22criteria%22%3A%5B%7B%22condition%22%3A%22%3D%22%2C%22data%22%3A%22appeared%22%2C%22origData%22%3A%22appeared%22%2C%22tags%22%3A%22num%22%2C%22value%22%3A%5B%222012%22%5D%7D%5D%2C%22logic%22%3A%22AND%22%7D 2012

#1511 on PLDB
12 Years Old

SIL is an SSA-form IR with high-level semantic information designed to implement the Swift programming language. In contrast to LLVM IR, SIL is a generally target-independent format representation that can be used for code distribution, but it can also express target-specific concepts as well as LLVM can.

- Tags: intermediate representation language
- Early development of SIL happened in Apple
- See also: (2 related languages) CIR, LLVM IR
- 2 PLDB concepts link to SIL: Rust HIR, Rust MIR

// SIL is reliant on Swift&#39;s type system and declarations, so SIL syntax is an extension of Swift&#39;s. A .sil file is a Swift source file with added SIL definitions. The Swift source is parsed only for its declarations; Swift func bodies (except for nested declarations) and top-level code are ignored by the SIL parser. In a .sil file, there are no implicit imports; the swift and/or Builtin standard modules must be imported explicitly if used.
sil_stage canonical

import Swift

// Define types used by the SIL function.

struct Point {
  var x : Double
  var y : Double
}

class Button {
  func onClick()
  func onMouseDown()
  func onMouseUp()
}

// Declare a Swift function. The body is ignored by SIL.
func taxicabNorm(_ a:Point) -&gt; Double {
  return a.x + a.y
}

// Define a SIL function.
// The name @_T5norms11taxicabNormfT1aV5norms5Point_Sd is the mangled name
// of the taxicabNorm Swift function.
sil @_T5norms11taxicabNormfT1aV5norms5Point_Sd : $(Point) -&gt; Double {
bb0(%0 : $Point):
  // func Swift.+(Double, Double) -&gt; Double
  %1 = function_ref @_Tsoi1pfTSdSd_Sd
  %2 = struct_extract %0 : $Point, #Point.x
  %3 = struct_extract %0 : $Point, #Point.y
  %4 = apply %1(%2, %3) : $(Double, Double) -&gt; Double
  return %4 : Double
}

// Define a SIL vtable. This matches dynamically-dispatched method
// identifiers to their implementations for a known static class type.
sil_vtable Button {
  #Button.onClick: @_TC5norms6Button7onClickfS0_FT_T_
  #Button.onMouseDown: @_TC5norms6Button11onMouseDownfS0_FT_T_
  #Button.onMouseUp: @_TC5norms6Button9onMouseUpfS0_FT_T_
}

print Hello World

Language features
======================================================

row
 Feature Print() Debugging
 FeatureLink ../features/hasPrintDebugging.html
 Supported ✓
 Example
 Token print
row
 Feature Comments
 FeatureLink ../features/hasComments.html
 Supported ✓
 Example
  // A comment
 Token 
row
 Feature Line Comments
 FeatureLink ../features/hasLineComments.html
 Supported ✓
 Example
  // A comment
 Token //
row
 Feature Semantic Indentation
 FeatureLink ../features/hasSemanticIndentation.html
 Supported X
 Example
 Token
