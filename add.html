<!DOCTYPE html>
<html lang="en">
<div class="scrollKeyboardNav" style="display:none;"><a href="download.html">download.html</a> Â· add.html Â· <a href="search.html">search.html</a><script>document.addEventListener('keydown', function(event) {
  if (document.activeElement !== document.body) return
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return // dont interfere with keyboard back button shortcut
  const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
  if (event.key === "ArrowLeft")
    getLinks()[0].click()
  else if (event.key === "ArrowRight")
    getLinks()[1].click()
 });</script></div>
<head>
 <meta charset="utf-8">
 <title>PLDB - Add Concept</title>
 <script>/* This HTML was generated by ðŸ“œ Scroll v138.4.0. https://scroll.pub */</script>
 <style>@media print {.doNotPrint {display: none !important;}}</style>
 <link rel="canonical" href="https://pldb.io/add.html">
 <meta name="viewport" content="width=device-width,initial-scale=1">
 <meta name="description" content="PLDB: a Programming Language Database. Build the next great programming language.">
 <meta name="generator" content="Scroll v138.4.0">
 <meta property="og:title" content="PLDB - Add Concept">
 <meta property="og:description" content="PLDB: a Programming Language Database. Build the next great programming language.">
 <meta property="og:image" content="">
 
 <link rel="source" type="application/git" title="Source Code Repository" href="https://github.com/breck7/pldb">
 <link rel="alternate" type="application/rss+xml" title="PLDB - Add Concept" href="./blog/feed.xml">
 <meta name="twitter:card" content="summary_large_image">
</head>
<body>
<link rel="stylesheet" type="text/css" href="./gazette.css"></link>
<link rel="stylesheet" type="text/css" href="./TrueBaseTheme.css"></link>

<div class="trueBaseThemeHeader">
 <a href="./index.html" class="trueBaseThemeLogo">PLDB</a>
 <form style="display:inline-block;" method="get" action="./search.html">
  <input type="search" id="trueBaseThemeHeaderSearch" name="q" placeholder="Search" autocomplete="off"></input>
</form>
 <a href="./lists/top1000.html">Top 1K</a>
 <a href="./lists/features.html">Features</a>
 <a href="./lists/creators.html">Creators</a>
 <a href="./lists/events.html">Events</a>
 <a href="./lists/podcasts.html">Podcasts</a>
 <a href="./books/index.html">Books</a>
 <a href="./lists/extensions.html">Extensions</a>
 <a href="./blog/interviews.html">Interviews</a>
 <a href="./blog/index.html">Blog</a>
 <a href="./lists/explorer.html">Explorer</a>
 <a href="./csv.html">CSV</a>
</div>

<style>.abstractIconButtonParser {position:absolute;top:0.25rem; }.abstractIconButtonParser svg {fill: rgba(204,204,204,.8);width:1.875rem;height:1.875rem; padding: 0 7px;} .abstractIconButtonParser:hover svg{fill: #333;}</style><a href="https://github.com/breck7/pldb/blob/main/add.scroll" class="doNotPrint abstractIconButtonParser" style="right:2rem;"><svg xmlns="http://www.w3.org/2000/svg" width="92pt" height="92pt" viewBox="0 0 92 92"><path d="M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371"/></svg></a>
<div class="scrollSection"><h1 id="particle27" class="scrollTitle"><a href="add.html">PLDB - Add Concept</a></h1>
</div>
<div class="scrollColumns" style="column-width:65ch;column-count:1;max-width:65ch;">
<link rel="stylesheet" href="codeMirror.css">
<script src="scrollLibs.js"></script>

<script>
sendFormViaEmail = form => {
  const mailto = new URL("mailto:")
  const params = []
  const { value, title } = form.querySelector('button[type="submit"]')
  params.push(`subject=${encodeURIComponent(value)}`)
  params.push(`to=${encodeURIComponent(title)}`)
  const oneTextarea = form.querySelector('textarea[title="oneTextarea"]')
  const body = oneTextarea ? codeMirrorInstance.getValue() : Array.from(new FormData(form)).map(([name, value]) => `${name} ${value}`).join("\n")
  params.push(`body=${encodeURIComponent(body)}`)
  mailto.search = params.join("&")
  window.open(mailto.href, '_blank')
}
</script><style> .scrollFormParser {
    font-family: "Gill Sans", "Bitstream Vera Sans", sans-serif;
  }
.scrollFormParser input , .scrollFormParser textarea{
padding: 10px;
margin-bottom: 10px;
width: 100%;
box-sizing: border-box;
} .scrollFormParser label {
  display: block;
  margin-bottom: 5px;
}
</style><form onsubmit='sendFormViaEmail(this); return false;' class="scrollFormParser"><textarea title="oneTextarea" rows="30" placeholder="" id="particles" name="particles"></textarea>
  <script id="particlesParsers" type="text/plain">// Basic atom types
blankAtom
anyAtom

// Enum atom types
enumAtom
 paint constant.language
booleanAtom
 enum true false
 extends enumAtom

// String atom types
stringAtom
 paint string

atomAtom
 paint string
 description A non-empty single atom string.
 regex .+

columnNameAtom
 extends stringAtom

semanticVersionAtom
 paint string
 description A 3 part sem version string like 1.2.1

// Date atom types
dateAtom
 paint string

// Numeric atom types
numberAtom
 paint constant.numeric
integerAtom
 extends numberAtom
 paint constant.numeric.integer
floatAtom
 extends numberAtom
 paint constant.numeric.float
percentAtom
 paint constant.numeric.float
 extends stringAtom
 // todo: this currently extends from stringAtom b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex
countAtom
 extends integerAtom
yearAtom
 extends integerAtom

// Scroll atom types
cueAtom
 description A atom that indicates a certain parser to use.
 paint keyword

preBuildCommandAtom
 extends cueAtom
 description Give build command atoms their own color.
 paint constant.character.escape

commentAtom
 paint comment

delimiterAtom
 description String to use as a delimiter.
 paint string

codeAtom
 paint comment

bulletPointAtom
 description Any token used as a bullet point such as "-" or "1." or ">"
 paint keyword

comparisonAtom
 enum < > <= >= = != includes doesNotInclude empty notEmpty
 paint constant

personNameAtom
 extends stringAtom

// Link atom types
urlAtom
 paint constant.language
absoluteUrlAtom
 paint constant.language
 regex (ftp|https?)://.+

emailAddressAtom
 extends stringAtom

// File system atom types
permalinkAtom
 paint string
 description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.

filePathAtom
 extends stringAtom

// HTML atom types
tagOrUrlAtom
 description An HTML tag or a url.
 paint constant.language

htmlAttributesAtom
 paint comment

htmlTagAtom
 paint constant.language
 enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code

classNameAtom
 paint constant

htmlIdAtom
 extends anyAtom


abstractScrollParser
 atoms cueAtom
 javascript
  compileEmbeddedVersion(compileSettings) {
   return this.compile(compileSettings)
  }
  compileTxt() {
    return ""
  }
  getHtmlRequirements(compileSettings) {
    const {requireOnce} = this
    if (!requireOnce)
      return ""
    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired
    if (set.has(requireOnce))
      return ""
    
    set.add(requireOnce)
    return requireOnce + "\n\n"
  }

abstractScrollWithRequirementsParser
 extends abstractScrollParser
 cruxFromId
 javascript
  compile(compileSettings) {
    return this.getHtmlRequirements(compileSettings) + this.compileInstance()
  }

metaCommandAtom
 extends cueAtom
 description Give meta command atoms their own color.
 paint constant.numeric
 // Obviously this is not numeric. But I like the green color for now.
   We need a better design to replace this "paint" concept
   https://github.com/breck7/scrollsdk/issues/186

abstractTopLevelSingleMetaParser
 description Use these parsers once per file.
 extends abstractScrollParser
 inScope slashCommentParser
 cruxFromId
 atoms metaCommandAtom
 javascript
  isTopMatter = true
  isSetterParser = true
  compile() {
   return ""
  }

scrollParser
 extensions scroll
 description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.
 root
 inScope abstractScrollParser blankLineParser
 catchAllParser errorParser
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  compile(compileSettings) {
    this.sectionStack = []
    return this.map(subparticle => subparticle.compile(compileSettings)).filter(i => i).join("\n") + this.clearSectionStack()
  }
  sectionStack = []
  clearSectionStack() {
   const result = this.sectionStack.join("")
   this.sectionStack = []
   return result
  }
  bodyStack = []
  clearBodyStack() {
   const result = this.bodyStack.join("")
   this.bodyStack = []
   return result
  }
  get hakonParser() {
    if (this.isNodeJs())
      return require("scrollsdk/products/hakon.nodejs.js")
    return hakonParser
  }
  readSyncFromFileOrUrl(fileOrUrl) {
    if (!this.isNodeJs()) return localStorage.getItem(fileOrUrl) || ""
    const isUrl = fileOrUrl.match(/^https?\:[^ ]+$/)
    if (!isUrl) return this.root.readFile(fileOrUrl)
    return this.readFile(this.makeFullPath(new URL(fileOrUrl).pathname.split('/').pop()))
  }
  async fetch(url, filename) {
    const isUrl = url.match(/^https?\:[^ ]+$/)
    if (!isUrl) return
    return this.isNodeJs() ? this.fetchNode(url, filename) : this.fetchBrowser(url)
  }
  makeFullPath(filename) {
    return require("path").join(this.file.folderPath, filename)
  }
  async fetchNode(url, filename) {
    filename = filename || new URL(url).pathname.split('/').pop()
    const fullpath = this.makeFullPath(filename)
    if (require("fs").existsSync(fullpath)) return this.readFile(fullpath)
    return this.downloadToDisk(url, fullpath)
  }
  async fetchBrowser(url) {
    const content = localStorage.getItem(url)
    if (content) return content
    return this.downloadToLocalStorage(url)
  }
  async downloadToDisk(url, destination) {
    const { writeFile } = require('fs').promises
    const response = await fetch(url)
    const fileBuffer = await response.arrayBuffer()
    await writeFile(destination, Buffer.from(fileBuffer))
    return this.readFile(destination)
  }
  async downloadToLocalStorage(url) {
    const response = await fetch(url)
    const blob = await response.blob()
    localStorage.setItem(url, await blob.text())
    return localStorage.getItem(url)
  }
  readFile(filename) {
    const path = require("path")
    const fs = require("fs")
    const fullPath = path.join(this.file.folderPath, filename)
    if (fs.existsSync(fullPath))
      return fs.readFileSync(fullPath, "utf8")
    console.error(`File '${filename}' not found`)
    return ""
  }
  alreadyRequired = new Set()
  compileEmbeddedVersion(compileSettings) {
   this.sectionStack = []
   return this.map(subparticle => (subparticle.compileEmbeddedVersion ? subparticle.compileEmbeddedVersion(compileSettings) : subparticle.compile(compileSettings)))
     .filter(i => i)
     .join("\n")
     .trim() + this.clearSectionStack()
  }
  get footnotes() {
   if (this._footnotes === undefined) this._footnotes = this.filter(particle => particle.isFootnote)
   return this._footnotes
  }
  async build() {
    await Promise.all(this.filter(particle => particle.build).map(async particle => particle.build()))
  }
  file = {}
  get title() {
    return this.file.title || this.get("title")
  }
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML.
  
  code
   // You can add code as well.
   print("Hello world")

abstractUrlSettingParser
 extends abstractTopLevelSingleMetaParser
 atoms metaCommandAtom urlAtom
 cruxFromId


buildCommandAtom
 extends cueAtom
 description Give build command atoms their own color.
 paint constant

abstractBuildCommandParser
 extends abstractScrollParser
 cruxFromId
 atoms buildCommandAtom
 catchAllAtomType filePathAtom
 inScope slashCommentParser
 javascript
  isTopMatter = true
  compile() {
   return ""
  }

commentLineParser
 catchAllAtomType commentAtom

abstractCommentParser
 description Prints nothing.
 catchAllAtomType commentAtom
 atoms commentAtom
 extends abstractScrollParser
 baseParser blobParser
 javascript
  compile() {
   return ``
  }
 catchAllParser commentLineParser

commentParser
 popularity 0.000193
 extends abstractCommentParser
 cruxFromId
 boolean suggestInAutocomplete false

slashCommentParser
 popularity 0.005643
 extends commentParser
 crux //
 boolean isPopular true
 description A comment. Prints nothing.
 boolean suggestInAutocomplete false

blankLineParser
 popularity 0.308149
 description Print nothing. Break section.
 atoms blankAtom
 boolean isPopular true
 javascript
  compile() {
   return this.parent.clearSectionStack()
  }
 pattern ^$
 tags doNotSynthesize

measureNameAtom
 extends cueAtom
 // A regex for column names for max compatibility with a broad range of data science tools:
 regex [a-zA-Z][a-zA-Z0-9]*

buildMeasuresParser
 popularity 0.000024
 cruxFromId
 description Write measures to csv+ files.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  atoms cueAtom anyAtom
 boolean suggestInAutocomplete false

// The main measure parser. All measures should extend from this.
abstractMeasureParser
 atoms measureNameAtom
 cruxFromId
 boolean isMeasure true
 float sortIndex 1.9
 boolean isComputed false
 string typeForWebForms text
 extends abstractScrollParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   return ""
  }
  get measureValue() {
    return this.content ?? ""
  }
  get measureName() {
    return this.getFirstAtomPath().replace(/ /g, "_")
  }

// String Measures
abstractAtomMeasureParser
 description A measure that contains a single atom.
 atoms measureNameAtom atomAtom
 extends abstractMeasureParser

abstractStringMeasureParser
 catchAllAtomType stringAtom
 extends abstractMeasureParser

abstractTextareaMeasureParser
 string typeForWebForms textarea
 extends abstractMeasureParser
 baseParser blobParser
 javascript
  get measureValue() {
    return this.subparticlesToString().replace(/\n/g, "\\n")
  }

abstractEmailMeasureParser
 string typeForWebForms email
 atoms measureNameAtom emailAddressAtom
 extends abstractAtomMeasureParser

// URL Parsers
abstractUrlMeasureParser
 string typeForWebForms url
 atoms measureNameAtom urlAtom
 extends abstractAtomMeasureParser

// Required ID measure which denotes a concept
abstractIdParser
 crux id
 description What is the ID of this concept?
 extends abstractStringMeasureParser
 float sortIndex 1
 boolean isMeasureRequired true
 boolean isConceptDelimiter true
 javascript
  getErrors() {
    const errors = super.getErrors()
    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== "id")
    if (!requiredMeasureNames.length) return errors
    let next = this.next
    while (requiredMeasureNames.length && next.firstAtom !== "id" && next.index !== 0) {
      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstAtom)
      next = next.next
    }
    requiredMeasureNames.forEach(name =>
      errors.push(this.makeError(`Concept "${this.content}" is missing required measure "${name}".`))
    )
    return errors
  }

// Numeric Measures
abstractNumericMeasureParser
 string typeForWebForms number
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }

abstractIntegerMeasureParser
 atoms measureNameAtom integerAtom
 extends abstractNumericMeasureParser

abstractFloatMeasureParser
 atoms measureNameAtom floatAtom
 extends abstractNumericMeasureParser

abstractPercentageMeasureParser
 atoms measureNameAtom percentAtom
 extends abstractNumericMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }

// Enum Measures
abstractEnumMeasureParser
 atoms measureNameAtom enumAtom
 extends abstractMeasureParser

// Boolean Measures
abstractBooleanMeasureParser
 atoms measureNameAtom booleanAtom
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : content == "true"
  }


errorParser
 baseParser errorParsertitle PLDB - Add Concept

tags All
viewSourceBaseUrl https://github.com/breck7/pldb/blob/main/

// Set the base url. Without this trick, browsing the site locally would require serving it via localhost to get relative url paths to work since we reuse the header and footer in nested folders. (There could be a better way to do this.)
keyboardNav

rssFeedUrl ./blog/feed.xml

baseUrl https://pldb.io/
description PLDB: a Programming Language Database. Build the next great programming language.
email feedback@pldb.io



metaTags

stumpNoSnippet
 link
  rel stylesheet
  type text/css
  href ./gazette.css
 link
  rel stylesheet
  type text/css
  href ./TrueBaseTheme.css

stumpNoSnippet
 div
  class trueBaseThemeHeader
  a PLDB
   href ./index.html
   class trueBaseThemeLogo
  form
   style display:inline-block;
   method get
   action ./search.html
   input
    type search
    id trueBaseThemeHeaderSearch
    name q
    placeholder Search
    autocomplete off
  a Top 1K
   href ./lists/top1000.html
  a Features
   href ./lists/features.html
  a Creators
   href ./lists/creators.html
  a Events
   href ./lists/events.html
  a Podcasts
   href ./lists/podcasts.html
  a Books
   href ./books/index.html
  a Extensions
   href ./lists/extensions.html
  a Interviews
   href ./blog/interviews.html
  a Blog
   href ./blog/index.html
  a Explorer
   href ./lists/explorer.html
  a CSV
   href ./csv.html

viewSourceButton


printTitle



mediumColumn
scrollForm breck7+pldb@gmail.com PLDB form submission
 value
  ../code/conceptPage.scroll
   
  id 
  name 
  appeared 
  creators 
  tags pl
  website 
  description 
  
  gitRepo 
  
  example
   

buildHtml
buildTxt

viewSourceLink

copyButtons

stumpNoSnippet
 div
  class trueBaseThemeFooter
  a PLDB
   href ./index.html
   class trueBaseThemeLogo
  span - Build the next great programming language
  span Â·
  a Add
   href ./add.html
  span Â·
  a About
   href ./pages/about.html
  span Â·
  a Search
   href ./search.html
  span Â·
  a Keywords
   href ./lists/keywords.html
  span Â·
  a Livestreams
   href ./lists/live.html
  span Â·
  a Labs
   href ./lists/labs.html
  span Â·
  a Resources
   href ./lists/resources.html
  span Â·
  a Acknowledgements
   href ./pages/acknowledgements.html
  span Â·
  a Part of the World Wide Scroll
   href https://wws.scroll.pub

./lists/autocompleteCombined.js
script document.addEventListener("DOMContentLoaded", evt => initAutocomplete("trueBaseThemeHeaderSearch"))

 </script>
  <script>{
  let {width, height} = document.getElementById('particles').getBoundingClientRect();
  const scrollParser = new HandParsersProgram(document.getElementById("particlesParsers").textContent).compileAndReturnRootParser()
  codeMirrorInstance = new ParsersCodeMirrorMode("custom", () => scrollParser, undefined, CodeMirror).register().fromTextAreaWithAutocomplete(document.getElementById("particles"), {
    lineWrapping: false,
    lineNumbers: false
  })
  codeMirrorInstance.setSize(width, height);
  codeMirrorInstance.setValue(`../code/conceptPage.scroll
 
id 
name 
appeared 
creators 
tags pl
website 
description 

gitRepo 

example
 `); }</script><button value="PLDB form submission" title="breck7+pldb@gmail.com" class="scrollButton" type="submit">Submit via email</button></form>
</div>
<div class="abstractTextLinkParser"><a href="https://github.com/breck7/pldb/blob/main/add.scroll">View source</a></div>
<script>
document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
 {
  if (!navigator.clipboard) return
  const button = document.createElement("span")
  button.classList.add("scrollCopyButton")
  block.appendChild(button)
  button.addEventListener("click", async () => {
    await navigator.clipboard.writeText(block.innerText)
    button.classList.add("scrollCopiedButton")
  })
 }
))
</script>


<div class="trueBaseThemeFooter">
 <a href="./index.html" class="trueBaseThemeLogo">PLDB</a>
 <span>- Build the next great programming language</span>
 <span>Â·</span>
 <a href="./add.html">Add</a>
 <span>Â·</span>
 <a href="./pages/about.html">About</a>
 <span>Â·</span>
 <a href="./search.html">Search</a>
 <span>Â·</span>
 <a href="./lists/keywords.html">Keywords</a>
 <span>Â·</span>
 <a href="./lists/live.html">Livestreams</a>
 <span>Â·</span>
 <a href="./lists/labs.html">Labs</a>
 <span>Â·</span>
 <a href="./lists/resources.html">Resources</a>
 <span>Â·</span>
 <a href="./pages/acknowledgements.html">Acknowledgements</a>
 <span>Â·</span>
 <a href="https://wws.scroll.pub">Part of the World Wide Scroll</a>
</div>

<script src="./lists/autocompleteCombined.js"></script>
<script>document.addEventListener("DOMContentLoaded", evt => initAutocomplete("trueBaseThemeHeaderSearch"))</script>
</body>
</html>