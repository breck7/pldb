printUsageStatsParser
 popularity 0.000096
 // todo: if we include the word "Parser" in a crux, bad things seem to happen.
 description Parser usage stats for folder.
 extends abstractScrollParser
 cruxFromId
 javascript
  get stats() {
   const input = this.root.file.allScrollFiles.map(file => file.parserIds.join("\n")).join("\n")
   const result = input.split('\n').reduce((acc, word) => (acc[word] = (acc[word] || 0) + 1, acc), {})
   const rows = Object.entries(result).map(([word, count]) => { return {word, count}})
   const sorted = this.lodash.sortBy(rows, "count").reverse()
   return "parserId uses\n" + sorted.map(row => `${row.word} ${row.count}`).join('\n')
  }
  get lodash() {
    return this.isNodeJs() ? require("lodash") : lodash
  }
  compile() {
    // A hacky but simple way to do this for now.
   const node = this.appendSibling("table")
   node.appendLine("delimiter  ")
   node.appendLine("printTable")
   const dataNode = node.appendLine("data")
    dataNode.setChildren(this.stats)
   const html = node.compile()
   node.destroy()
   return html
  }
  compileTxt() {
    return this.stats
  }
  compileCsv() {
    return this.stats.replace(/ /g, ",")
  }

// todo: these should not be keywords in stdlib, but should be made through componsition of more reusable parsers in a dataflow style.

printScrollLeetSheetParser
 popularity 0.000024
 description Print Scroll parser leet sheet.
 extends abstractScrollParser
 cruxFromId
 javascript
  get parsersToDocument() {
    const clone = this.root.clone()
    clone.setChildren("")
    const words = clone.getAutocompleteResultsAt(0,0).matches.map(a => a.text)
    words.push("blankline") // manually add blank line
    words.push("Catch All Paragraph.") // manually add catch all paragraph
    words.push("<h></h>") // manually add html
    words.sort()
    clone.setChildren(words.join("\n").replace(/blankline/, "")) // insert blank line in right spot
    return clone
  }
  sortDocs(docs) {
    return docs.map(node => {
      const {definition} = node
      const {id, description, isPopular, examples, popularity} = definition
      const tags = definition.get("tags") || ""
      if (tags.includes("deprecate") || tags.includes("experimental"))
        return null
      const category = this.getCategory(tags)
      const note = this.getNote(category)
      return {id: definition.cruxIfAny || id, description, isPopular, examples, note, popularity: Math.ceil(parseFloat(popularity) * 100000)}
     }).filter(i => i).sort((a, b) => a.id.localeCompare(b.id))
  }
  makeLink(examples, crux) {
    // if (!examples.length) console.log(crux) // find nodes that need docs
    const example = examples.length ? examples[0].childrenToString() : crux
    const base = `https://try.scroll.pub/`
    const tree = new TreeNode()
    tree.appendLineAndChildren("scroll", "gazetteCss\n" + example)
    return base + "#" + encodeURIComponent(tree.asString)
  }
  docToHtml(doc) {
   const css = `#scrollLeetSheet {color: grey;} #scrollLeetSheet a {color: #3498db; }`
   return `<style>${css}</style><div id="scrollLeetSheet">` + doc.map(obj => `<div class="${obj.category}"><a href="${this.makeLink(obj.examples, obj.id)}">${obj.isPopular ? "<b>" : ""}${obj.id}</a> ${obj.description}${obj.isPopular ? "</b>" : ""}${obj.note}</div>`).join("\n") + "</div>"
  }
  compile() {
    return this.docToHtml(this.sortDocs(this.parsersToDocument))
  }
  compileTxt() {
   return this.sortDocs(this.parsersToDocument).map(obj => `${obj.id} - ${obj.description}`).join("\n")
  }
  get lodash() {
    return require("lodash")
  }
  getCategory(input) {
    return ""
  }
  getNote() {
    return ""
  }
  compileCsv() {
    const rows = this.sortDocs(this.parsersToDocument).map(obj => {
      const {id, isPopular, description, popularity, category} = obj
      return {
        id,
        isPopular,
        description,
        popularity,
        category
      }
    })
    return new TreeNode(this.lodash.sortBy(rows, "isPopular")).asCsv
  }

printparsersLeetSheetParser
 popularity 0.000024
 // todo: fix parse bug when word Parser appears in parserId
 extends printScrollLeetSheetParser
 description Parsers leetsheet.
 javascript
  compile() {
    return "<p><b>Line Parsers</b> match lines and parse them.</p>" + this.docToHtml(this.sortDocs(this.parsersToDocument)) + "<p><b>Cell Parsers</b> parse words in a line.</p>" + this.docToHtml(this.sortDocs(this.cellParsersToDocument))
  }
  makeLink() {
    return ""
  }
  categories = "assemblePhase acquirePhase analyzePhase actPhase".split(" ")
  getCategory(tags) {
    return tags.split(" ").filter(w => w.endsWith("Phase"))[0]
  }
  getNote(category) {
    return ` <span class="note">A${category.replace("Phase", "").substr(1)}Time.</span>`
  }
  get cellParsersToDocument() {
    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")
    const clone = new parsersParser("anyCell\n ").clone()
    const parserNode = clone.getNode("anyCell")
    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)
    words.sort()
    parserNode.setChildren(words.join("\n"))
    return parserNode
  }
  get parsersToDocument() {
    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")
    const clone = new parsersParser("latinParser\n ").clone()
    const parserNode = clone.getNode("latinParser")
    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)
    words.sort()
    parserNode.setChildren(words.join("\n"))
    return parserNode
  }

