abstractTableTransformParser
 inScope abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser
 javascript
  get coreTable() {
    return this.parent.coreTable
  }
  get columnNames() {
    return this.parent.columnNames
  }

abstractTableVisualizationParser
 extends abstractScrollWithRequirementsParser
 boolean isTableVisualization true

printTableParser
 cruxFromId
 extends abstractTableVisualizationParser
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   return this.parent.columnNames
  }
  get columns() {
   const {columnNames} = this
   return columnNames.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = columnNames.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  toRow(row) {
    const {columns} = this
    const words = columns.map(col => row[col.name])
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = ((columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? "").toString()
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (content.match(/^https?\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
  get tableBody() {
   return this.parent.coreTable
    .map(row => `<tr>${this.toRow(row)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table id="table${this._getUid()}" class="scrollTable">
   <thead><tr>${this.tableHeader.join("\n")}</tr></thead>
   <tbody>${this.tableBody}</tbody>
   </table>
   <script>
   document.querySelector('#table${this._getUid()}').addEventListener('click', e => {
    if (window.getSelection().toString() || e.target.closest('a') || !e.target.closest('tbody')) return;
    e.currentTarget.classList.toggle('expandedTable');
   });
   </script>`
  }
  compileTxt() {
    return this.parent.delimitedData || new TreeNode(this.parent.coreTable).asCsv
  }

scrollTableDataParser
 crux data
 description Table from inline delimited data.
 catchAllCellType anyCell
 baseParser blobParser

scrollTableDelimiterParser
 description Set the delimiter.
 crux delimiter
 cells commandWordCell stringCell
 javascript
  compile() {
    return ""
  }

scrollTableParser
 description A table.
 crux table
 extends abstractScrollParser
 catchAllCellType filePathCell
 inScope scrollTableDataParser scrollTableDelimiterParser abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser
 javascript
  get visualizations() {
    return this.topDownArray.filter(node => node.isTableVisualization || node.isHeader)
  }
  compile() {
   return this.visualizations.map(node => node.compile())
     .join("\n")
     .trim()
  }
  compileTxt() {
    return this.visualizations.map(node => node.compileTxt())
     .join("\n")
     .trim()
  }
  get delimiter() {
    const {filename} = this
    let delimiter = " " // space is default delimiter if not specified
    if (filename) {
      const extension = filename.split(".").pop()
      if (extension === "json") delimiter = "json"
      if (extension === "tree") delimiter = "tree"
      if (extension === "csv") delimiter = ","
      if (extension === "tsv") delimiter = "\t"
    }
    if (this.get("delimiter"))
      delimiter = this.get("delimiter")
    return delimiter
  }
  get filename() {
    return this.content
  }
  get fileContent() {
    const {filename} = this
    const { Disk } = require("scrollsdk/products/Disk.node.js")
    const path = require("path")
    const {file} = this.parent
    return Disk.read(path.join(file.folderPath, filename))
  }
  get delimitedData() {
    // json csv tsv
    if (this.filename)
      return this.fileContent
    
    return this.getNode("data")?.childrenToString() || ""
  }
  _coreTable
  get coreTable() {
    if (this._coreTable) return this._coreTable
    const {delimiter, delimitedData} = this
    if (delimiter === "json")
       this._coreTable = JSON.parse(delimitedData)
    else if (delimiter === "tree") {
       const d3lib = typeof d3 === "undefined" ? require('d3') : d3
       this._coreTable = d3lib.dsvFormat(",").parse(new TreeNode(delimitedData).asCsv, d3lib.autoType)
    } else {
      const d3lib = typeof d3 === "undefined" ? require('d3') : d3
      this._coreTable = d3lib.dsvFormat(delimiter).parse(delimitedData, d3lib.autoType)
    }
    this._columnNames = this._coreTable.columns
    delete this._coreTable.columns
    return this._coreTable
  }
  get columnNames() {
    // init coreTable to set columns
    const coreTable = this.coreTable
    return this._columnNames
  }

scrollWhereParser
 extends abstractTableTransformParser
 description Each row must meet a certain condition
 crux where
 cells commandWordCell columnNameCell comparisonCell numberCell
 example
  table iris.csv
   where Species = setosa
 javascript
  get coreTable() {
   // todo: use cells here.
   const columnName = this.getWord(1)
   const operator = this.getWord(2)
   let untypedScalarValue = this.getWord(3)
   const typedValue = isNaN(parseFloat(untypedScalarValue)) ? untypedScalarValue : parseFloat(untypedScalarValue)
   const coreTable = this.parent.coreTable
   if (!columnName || !operator || untypedScalarValue === undefined) return coreTable
    const filterFn = row => {
      const cell = row[columnName]
      const typedCell = cell
      if (operator === "=") return typedValue === typedCell
      else if (operator === "!=") return typedValue !== typedCell
      else if (operator === "includes") return typedCell !== undefined && typedCell.includes(typedValue)
      else if (operator === "doesNotInclude") return typedCell === undefined || !typedCell.includes(typedValue)
      else if (operator === ">") return typedCell > typedValue
      else if (operator === "<") return typedCell < typedValue
      else if (operator === ">=") return typedCell >= typedValue
      else if (operator === "<=") return typedCell <= typedValue
      else if (operator === "empty") return cell === "" || cell === undefined
      else if (operator === "notEmpty") return !(cell === "" || cell === undefined)
    }
   return coreTable.filter(filterFn)
  }

tableSearchParser
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js dataTables.dataTables.min.css dataTables.min.js tableSearch.js
 string requireOnce
  <script defer src="jquery-3.7.1.min.js"></script>
  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>
  <link rel="stylesheet" href="dataTables.dataTables.min.css">
  <script defer src="dataTables.min.js"></script>
  <script defer src="tableSearch.js"></script>
 // adds to all tables on page
 description Table search and sort widget.
 javascript
  compileInstance() {
   return ""
  }
