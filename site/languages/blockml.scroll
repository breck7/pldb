import header.scroll

title blockml

title blockml - Text markup language
 hidden

html
 <a class="prevLang" href="concise-encoding.html">&lt;</a>
 <a class="nextLang" href="sysml.html">&gt;</a>

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/blockml.pldb

startColumns 4

html <div class="quickLinks"><a href="http://blockml.awwapps.com"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.7166 3.79541C12.2835 3.49716 11.7165 3.49716 11.2834 3.79541L4.14336 8.7121C3.81027 8.94146 3.60747 9.31108 3.59247 9.70797C3.54064 11.0799 3.4857 13.4824 3.63658 15.1877C3.7504 16.4742 4.05336 18.1747 4.29944 19.4256C4.41371 20.0066 4.91937 20.4284 5.52037 20.4284H8.84433C8.98594 20.4284 9.10074 20.3111 9.10074 20.1665V15.9754C9.10074 14.9627 9.90433 14.1417 10.8956 14.1417H13.4091C14.4004 14.1417 15.204 14.9627 15.204 15.9754V20.1665C15.204 20.3111 15.3188 20.4284 15.4604 20.4284H18.4796C19.0806 20.4284 19.5863 20.0066 19.7006 19.4256C19.9466 18.1747 20.2496 16.4742 20.3634 15.1877C20.5143 13.4824 20.4594 11.0799 20.4075 9.70797C20.3925 9.31108 20.1897 8.94146 19.8566 8.7121L12.7166 3.79541ZM10.4235 2.49217C11.3764 1.83602 12.6236 1.83602 13.5765 2.49217L20.7165 7.40886C21.4457 7.91098 21.9104 8.73651 21.9448 9.64736C21.9966 11.0178 22.0564 13.5119 21.8956 15.3292C21.7738 16.7067 21.4561 18.4786 21.2089 19.7353C20.9461 21.0711 19.7924 22.0001 18.4796 22.0001H15.4604C14.4691 22.0001 13.6655 21.1791 13.6655 20.1665V15.9754C13.6655 15.8307 13.5507 15.7134 13.4091 15.7134H10.8956C10.754 15.7134 10.6392 15.8307 10.6392 15.9754V20.1665C10.6392 21.1791 9.83561 22.0001 8.84433 22.0001H5.52037C4.20761 22.0001 3.05389 21.0711 2.79113 19.7353C2.54392 18.4786 2.22624 16.7067 2.10437 15.3292C1.94358 13.5119 2.00338 11.0178 2.05515 9.64736C2.08957 8.73652 2.55427 7.91098 3.28346 7.40886L10.4235 2.49217Z"/></svg></a> <a href="https://github.com/Lindemann/BlockML"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a> <a href="https://twitter.com/awwapps"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg></a></div>

* blockml is a <a href="../lists/languages.html?filter=textMarkup">text markup language</a> created in 2014.
 link ../lists/languages.html?filter=2014 2014

kpiTable
 #610 <span title="TotalRank: 1175 Jobs: 103 Users: 2322 Facts: 100 Links: 972">on PLDB</span>
 9 Years Old
 0 <span title="Books about or leveraging blockml">Books</span>
 0 <span title="Academic publications about or leveraging blockml">Papers</span>

* BlockML is a lightweight markup language for scientific documents.

- blockml website
 http://blockml.awwapps.com
- blockml is developed on <a href="https://github.com/Lindemann/BlockML">GitHub</a> and has 4 stars
- blockml first developed in <a href="../lists/originCommunities.html#awwApps">Aww Apps</a>
- blockml on Twitter
 https://twitter.com/awwapps
- HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
- <a href="https://pldb.com/edit/blockml">Improve our blockml file</a>

html <br>

codeWithHeader Example from the web:
 /*
     ____  __           __   __  _____ 
    / __ )/ /___  _____/ /__/  |/  / / 
   / __  / / __ \/ ___/ //_/ /|_/ / /  
  / /_/ / / /_/ / /__/ ,&lt; / /  / / /___
 /_____/_/\____/\___/_/|_/_/  /_/_____/
 
 */
 
 
 head[
 
 title[Recap of John McCarthy&#39;s Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I]
 
 h3[Judith Lindemann]
 
 h5[Berlin, 25 December 2013]
 
 ]
 
 h1[Preface]
 
 This text is originated as an exercise for an university course about scientific writing at the Beuth University of Applied Sciences Berlin. The assignment was to choose a  computer science paper, reproduce the key ideas in own words, and add some own thoughts about that topic as conclusion. 
 
 I have selected the classical paper &quot;b[Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I]&quot; by John McCarthy from 1960 (id[LISP]), because it  permits a fascinating look into the history of programming languages and is the origin of many concepts that are still relevant today.
 
 This text is also influenced by Paul Graham&#39;s article &quot;b[Roots of Lisp]&quot; from 2002 (id[ROOTS]) about that McCarthy paper. I follow Paul Graham&#39;s approach to provide code  examples in actual LISP code instead of m-expressions, and I assume that c[quote] and c[cond] are elementary functions.
 
 toc[Contents]
 
 sec[Introduction][
 
 The paper (id[LISP]) describes a dynamic typed and functional programming language called LISP. The name LISP is an abbreviation for b[LIS]t b[P]rocessor, which is a very  suitable name, because the whole syntax is completely based on a simple list notation for code and data.
 
 LISP was developed in 1958, two years before the paper was published. The main purpose for the development was the lack of appropriate programming languages for artificial  intelligence applications. At this time FORTRAN was the dominant high level programming language, but it was developed for numeric calculations and engineering tasks and  therefore no good fit for AI problems.
 
 LISP was influenced by IPL (Information Processing Language), which was an experimental programming language from 1957 (see id[IPL]). IPL was dedicated to AI research, but also  inappropriate because it was an assembly language. Some of the IPL concepts that LISP had adopted and heavily improved were: list-processing, higher-order functions, recursion  and computation with symbols. Some other concepts were new, for example: conditional control flow, garbage collection, lazy evaluation, and dynamic typing.
 
 At first, we will learn something about the mathematical concepts behind LISP. Then, we will see that the early LISP had only two simple data types. After that, we will define  5-7 elementary functions and we will use them as building blocks to create our own functions. Then, we will see how the memory management works. At the end, we will look, how  LISP was doing in the past 55 years and how LISP is doing today.
 
 ]/* Introduction */
 
 sec[Mathematical concepts][
 
 sec[Propositional expressions][
 Propositional expressions are expressions whose values are either c[T] &quot;true&quot; or c[F] &quot;false&quot;. These expressions are often combined by connectives like c[âˆ§] &quot;and&quot;, c[âˆ¨] &quot;or&quot;  and c[Â¬] &quot;not&quot;. Typical examples are:
 
 math[$$x &lt; y$$
 $$(x &lt; y) \land (b = c)$$]
 
 ]/* Propositional Expressions */
 
 sec[Conditional expressions][
 The notation of conditional expressions was a new concept, developed by McCarthy in 1960. It is the ancestor of the &quot;if...then...else&quot; condition, who is part of nearly every  programming language nowadays. Conditional expressions allow a recursive definition of functions in a convenient way. A conditional expression has the form:
 
 math[$$(p_1 \rightarrow e_1,\cdots,p_n \rightarrow e_n)$$]
 
 The b[p]â€™s are propositional expressions that are true or false. The b[e]â€™s could be any kind of expression. One could read &quot;if b[p]sub[1] then b[e]sub[1], else if b[p] sub[2] then b[e]sub[2], ..., else if b[p]sub[n] then b[e]sub[n]&quot; or &quot;b[p]sub[1] yields b[e]sub[1], ..., b[p]sub[n] yields b[e]sub[n]&quot;.
 
 The b[p]â€™s get evaluate from left to right. When the first true b[p] is found, then the conditional expressions returns the b[e] that belongs to the b[p].
 
 math[$$(1 &lt; 2 \rightarrow 4, 1 &gt; 2 \rightarrow 3) = 4$$
 
 $$(2 &lt; 1 \rightarrow 4, 2 &gt; 1 \rightarrow 3, 2 &gt; 1 \rightarrow 2) = 3$$
 
 $$(2 &lt; 1 \rightarrow 4, T \rightarrow 3) = 3$$
 
 $$(2 &lt; 1 \rightarrow {0 \over 0}, T \rightarrow 3) = 3$$]
 
 The whole conditional expressions is undefined:
 ol[
 - if all b[p]&#39;s are false, 
 - if an undefined b[p] occurs before a true b[p] occurs 
 - or if the b[e] that belongs to the first true b[p] is undefined it self
 ]
 
 math[$$(2 &lt; 1 \rightarrow 3, 4 &lt; 1 \rightarrow 4) \mbox{ is undefined}$$
 
 $$({0 \over 0} &lt; 1 \rightarrow 3, 1 &lt; 4 \rightarrow 4) \mbox{ is undefined}$$
 
 $$(2 &lt; 1 \rightarrow 3, T \rightarrow {0 \over 0} )\mbox{ is undefined}$$]
 
 ][COND]/* Conditional expressions */
 
 sec[Recursive function definitions][
 
 With the help of conditional expressions it is easy to define recursive functions. The factorial of a non-negative integer b[n] could be described as follows:
 
 math[$$n! = (n = 0 \rightarrow 1, T \rightarrow n \cdot(n - 1)!)$$]
 
 The evaluation of 0! returns 1. The evaluation of 2! looks as follows:
 
 math[\\begin{eqnarray*}
 2! &amp;=&amp; (2 = 0 \\rightarrow 1, T \\rightarrow 2 \\cdot (2 - 1)!)\\\\
 &amp;=&amp; 2 \\cdot 1!\\\\
 &amp;=&amp; 2 \\cdot (1 = 0 \\rightarrow 1 T \\rightarrow \\cdot (1 - 1)!)\\\\
 &amp;=&amp; 2 \\cdot 1 \\cdot 0!\\\\
 &amp;=&amp; 2 \\cdot 1 \\cdot (0 = 0 \\rightarrow 1, T \\rightarrow 0\\cdot(0-1)!)\\\\
 &amp;=&amp;2\\cdot1\\cdot1\\\\
 &amp;=&amp;2
 \\end{eqnarray*}]
 
 ]/* Recursive function definitions */
 
 sec[Lambda calculus][
 The Lambda calculus is a formal notation, which is used in LISP to generate new functions and to use functions as arguments. It was introduced by Alonzo Church in 1941 (see id[ LAMBDA]).
 
 Church distinguishes between forms and functions. An expression like im[$y^2 + x$] is a form. An expression like im[$f(3, 4)$ ] a function. im[$y^2 + x$] is not a function  because the expression im[$y^2 + x(3, 4)$] does not determine and could turn into 19 or 13. The problem is that the order, in which the arguments 3 and 4 are inserted into the  form, is undefined. To convert a form into a function we can write: is $2.50 for the first one, and $2.00 for each additional one
 
 math[$$\lambda((x_1, \cdots, x_n),\cal E)$$]
 
 im[$\cal E$] is a form and im[$x_1, \cdots, x_n$] are the ordered parameters for im[$\cal E$]. The Î»-expression is a function because the variables in im[$\cal E$] can be  substituted with arguments in the order of the parameter list im[$x_1, \cdots, x_n$]. We say that the variables of a Î»-expression are bounded. The example from above looks now  like this:
 
 math[$$\lambda((x,y),y^2 +x)$$]
 
 And with arguments like this:
 
 math[$$\lambda((x,y),y^2 +x)(3,4) = 19$$]
 
 
 If we want to define a recursive function like
 
 math[$${\rm sqrt}(a,x,\epsilon)
         = (|x^2 - a| &lt; \epsilon \rightarrow x, T \rightarrow {\rm sqrt}(a,
 {1 \over 2}(x + {a \over x}),\epsilon))$$]
 
 in lambda notation
 
 math[$${\rm sqrt} = \lambda((a,x,\epsilon),(|x^2 - a| &lt; \epsilon \rightarrow x,
 T\rightarrow
 {\rm sqrt} (a,{1 \over 2}(x + {a \over x}), \epsilon))),$$]
 
 we found that these definition is inadequate, because the right-hand side im[$sqrt$] can not serve as an expression for the whole function. Remember, a function would look like  im[$sqrt(a,x,Îµ)$].
 
 In order to define recursive Î»-expressions, we must introduce a new notation.
 
 math[$$label(f,\cal E)$$]
 
 b[f] can be seen as the function name. The occurrence of b[f] within im[$\cal E$] will be evaluated to the label-expression as if b[f] is a parameter of the function. 
 
 math[$$label(sqrt, \lambda((a,x,\epsilon),(| x^2 - a|
 &lt; \epsilon \rightarrow x, T \rightarrow {\rm sqrt} (a, {1 \over 2}(x + {a
 \over x}),\epsilon))))$$]
 
 ][LAMBDACALCULUS]/* Lambda calculus */
 
 ]/* Mathematical concepts behind Lisp */

endColumns

## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Booleans
  FeatureLink ../features/hasBooleans.html
  Supported <span class="hasFeature">✓</span>
  Token true false
  Example
 row
  Feature Comments
  FeatureLink ../features/hasComments.html
  Supported <span class="hasFeature">✓</span>
  Token 
  Example
   /* A comment
   */
 row
  Feature MultiLine Comments
  FeatureLink ../features/hasMultiLineComments.html
  Supported <span class="hasFeature">✓</span>
  Token /* */
  Example
   /* A comment
   */
 row
  Feature Semantic Indentation
  FeatureLink ../features/hasSemanticIndentation.html
  Supported <span class="doesNotHaveFeature">X</span>
  Token 
  Example

## HackerNews discussions of blockml

pipeTable
 title|titleLink|date|score|comments
 Show HN: BlockML – A markup language for scientific documents|https://news.ycombinator.com/item?id=7698827|05/05/2014|3|0

keyboardNav concise-encoding.html sysml.html

import ../footer.scroll
